#!/usr/share/ucs-test/runner python
## desc: ucs-school-assign_internet_rules_check
## roles: [domaincontroller_master, domaincontroller_backup, domaincontroller_slave, memberserver]
## tags: [apptest]
## exposure: dangerous
## packages:  [ucs-school-umc-internetrules]

from univention.lib.umc_connection import UMCConnection
import random
import sys
import univention.testing.strings as uts
import univention.testing.ucr as ucr_test
import univention.testing.ucsschool as utu
import univention.testing.utils as utils


"""""""""""""""""""""""""""""""""""""""
  Class RandomDomains
  Generates random domains
"""""""""""""""""""""""""""""""""""""""
class RandomDomain():
# Initialization
	def __init__(self):
		DOMAIN_NAMES = ["de","com","net","org","gov","info","me",
							   "email","eu","at","uk","co","ag","sy"]
		self.__name = uts.random_string()
		self.__tail = random.choice(DOMAIN_NAMES)
		self.__domain = '%s.%s' % (self.__name, self.__tail)

# single domain getter
	def name(self):
		return self.__domain

# multi domain getter as a list of domain names
	def getDomainList(self, count):
		domainList = []
		for i in range(count):
			domain = self.__class__()
			domainList.append(domain.name())
		return domainList


"""""""""""""""""""""""""""""""""""""""
  Class InternetRule
  All the operations related to internet rules
"""""""""""""""""""""""""""""""""""""""
class InternetRule():
# Initialization (by default all are random)
	def __init__(self, name=None, typ=None, domains=None, wlan=None, priority=None):
		priorities = [1,2,3,4,5,6,7,8,9,10]
		if name:
			self.__name = name
		else:
			self.__name = uts.random_string()
		if typ:
			self.__type = typ
		else:
			typs = ['whitelist', 'blacklist']
			self.__type = random.choice(typs)
		if domains:
			self.__domains = domains
		else:
			dom = RandomDomain()
			domains = dom.getDomainList(random.choice(priorities))
			self.__domains = domains
		if wlan:
			self.__wlan = wlan
		else:
			wlans = [True, False]
			self.__wlan = random.choice(wlans)
		if priority:
			self.__priority = priority
		else:
			self.__priority =  random.choice(priorities)

# name getter
	def name(self):
		return self.__name

# define rule umcp
	def define(self, umcConnection):
		param = [
				{
					'object':
					{
						'name':self.__name,
						'type':self.__type,
						'domains': self.__domains,
						'wlan': self.__wlan,
						'priority': self.__priority
						}
					}
				]
		if not umcConnection.request('internetrules/add', param)[0]['success']:
			utils.fail('Unable to define rule (%r)' % (param))

# get the internet rule umcp
	def get(self, umcConnection, expectedResult):
		if bool(umcConnection.request('internetrules/get', [self.__name])) != expectedResult:
			utils.fail('Unexpected i fetching result for internet rule (%r)'  % (self.__name))

# try to modify the internet rule
	def put(self, umcConnection, newName, newtype, newDomains, newWlan, newPriority):
		param = [
				{
					'object':
					{
						'name':newName,
						'type':newtype,
						'domains': newDomains,
						'wlan': newWlan,
						'priority': newPriority
						},
					'options' : { 'name': self.__name }
					}
				]
		if not umcConnection.request('internetrules/put', param)[0]['success']:
			utils.fail('Unable to modify rule (%r)' % (param))
		else:
			self.__name = newName
			self.__type = newtype
			self.__domains = newDomains
			self.__wlan = newWlan
			self.__priority = newPriority

# try to remove  the internet rule
	def remove(self, umcConnection):
		options = [{ 'object': self.__name }]
		if not umcConnection.request('internetrules/remove', options )[0]['success']:
			utils.fail('Unable to remove rule (%r)' % (self.__name))

# Fetch the values from ucr and check if it matches the correct values for the rule
	def checkUcr(self, ucr, expectedResult):
		ucr.load()
		# extract related items from ucr
		exItems =  dict([
			(key.split('/')[-1], value) for (key, value) in ucr.items() if self.__name	in key
			])
		if bool(exItems) != expectedResult:
			utils.fail('Unexpected registery items fetched (expectedResult=%r items=%r)'
					% (expectedResult, exItems))
		elif expectedResult:
			wlan = str(self.__wlan).lower()
			typ = self.__type
			if self.__type == "whitelist":
				typ = "whitelist-block"
			elif self.__type == "blacklist":
				typ = "blacklist-pass"
			curtype = exItems['filtertype']
			curWlan = exItems['wlan']
			curPriority = exItems['priority']
			exDomains = dict([
				(key, value) for (key, value) in exItems.items() if unicode(key).isnumeric()
				])
			curDomains = sorted(exDomains.values())
			if (curtype, curPriority, curWlan, curDomains) != (typ, self.__priority, wlan, self.__domains):
				utils.fail('Values in UCR are not updated for rule (%r)' % (self.__name))

# Assign internet rules to workgroups/classes
# return a tuple (groupName, ruleName)
	def assign(self, umcConnection, school, groupName, basedn, groupType, default=False):
		groupdn = ''
		if groupType == 'workgroup':
			groupdn = 'cn=%s-%s,cn=schueler,cn=groups,ou=%s,%s' % (school,
					groupName, school, basedn)
		elif groupType == 'class':
			groupdn = 'cn=%s-%s,cn=klassen,cn=schueler,cn=groups,ou=%s,%s' % (school,
					groupName, school, basedn)
		if default:
			name = '$default$'
		else:
			name = self.__name
		param = [
				{
					'group': groupdn,
					'rule': name
					}
				]
		result = umcConnection.request('internetrules/groups/assign', param)
		if not result:
			utils.fail('Unable to assign internet rule to workgroup (%r)' % (param))
		else:
			return (groupName, self.__name)

# define multi rules and return list of rules Objects
	def defineList(self, umcConnection, count):
		ruleList = []
		for i in range(count):
			rule = self.__class__()
			rule.define(umcConnection)
			ruleList.append(rule)
		return ruleList


"""""""""""""""""""""""""""""""""""""""
  Class RandomClass
"""""""""""""""""""""""""""""""""""""""
class RandomClass():
# Initialization
	def __init__(self):
		self.__name = uts.random_string()
		self.__description = uts.random_string()

# name getter
	def name(self):
		return self.__name

# create random classes
	def create(self, umcConnection, school):
		flavor = 'schoolwizards/classes'
		param = {
				'name': self.__name,
				'school': school,
				'description': self.__description,
				}
		if umcConnection.request('schoolwizards/classes/create', param, flavor) != None:
			utils.fail('Unable to create class (%r)' % (param))

# create list of random classes returns list of class objects
	def createList(self, umcConnection, school, count):
		cList = []
		for i in range(count):
			c = self.__class__()
			c.create(umcConnection, school)
			cList.append(c)
		return cList


"""""""""""""""""""""""""""""""""""""""
  Class RandomWorkgroup
"""""""""""""""""""""""""""""""""""""""
class RandomWorkgroup():
# Initialization
	def __init__(self):
		self.__name = uts.random_string()
		self.__description = uts.random_string()
		self.__members = []

# name getter
	def name(self):
		return self.__name

# Create random workgroups
	def create(self, umcConnection, school):
		flavor = 'workgroup-admin'
		param = [
				{
					'object': {
						'name': self.__name,
						'school': school,
						'members': self.__members,
						'description': self.__description
						}
					}
				]
		if not umcConnection.request('schoolgroups/add', param, flavor):
			utils.fail('Unable to add workgroup (%r)' % (param))

# create list of random workgroups returns list of groups objects
	def createList(self, umcConnection, school, count):
		groupList = []
		for i in range(count):
			g = self.__class__()
			g.create(umcConnection, school)
			groupList.append(g)
		return groupList


"""""""""""""""""""""""""""""""""""""""
  Class Check
  resposible of all the checks operations on rules/groups
"""""""""""""""""""""""""""""""""""""""
class Check():
# Initialization
	def __init__(self, school, groupRuleCouples):
		self.__school = school
		self.__groupRuleCouples = groupRuleCouples

# check if the assigned internet rules are correct UMCP
	def checkRules(self, umcConnection):
		for  groupName,ruleName  in self.__groupRuleCouples:
			param = {
					'school': self.__school,
					'pattern': groupName
					}
			if ruleName == None:
				ruleName = '-- default settings --'
			result = umcConnection.request('internetrules/groups/query', param)
			if result[0]['rule'] != ruleName:
				utils.fail('Assigned internetrule (%r) to workgroup (%r) does not match' % (ruleName, groupName))

# check ucr variables for groups/ classes internet rules
	def checkUcr(self, ucr):
		ucr.load()
		for groupName, ruleName in self.__groupRuleCouples:
			groupid = 'proxy/filter/groupdefault/%s-%s' % (self.__school, groupName)
			if ucr.get(groupid) != ruleName:
				utils.fail('Ucr variable (%r) is not correctly set' % (groupid))


def main():
	with utu.UCSTestSchool()  as schoolenv:
		with ucr_test.UCSTestConfigRegistry() as ucr:
			host = ucr.get('hostname')
			basedn = ucr.get('ldap/base')
			connection = UMCConnection(host)
			connection.auth('Administrator' ,'univention')
			school, oudn = schoolenv.create_ou()

			# define many random internet rules
			ruleIns = InternetRule()
			newRules = ruleIns.defineList(connection, 8)

			# test get the created rules via umc
			for rule in newRules:
				rule.get(connection, True)

			# Create random workgroups
			groupIns = RandomWorkgroup()
			newWorkgroups = groupIns.createList(connection, school, 2)
			assignedGroups = [(group.name(),None) for group in newWorkgroups]

			check1 = Check(school, assignedGroups)

			# check the assigned internet rules UMCP
			check1.checkRules(connection)

			# check ucr variables
			check1.checkUcr(ucr)

			# assign internetrules to groups randomly
			rules = newRules[:4]
			assignedGroups = []
			for group in newWorkgroups:
				rule = random.choice(rules)
				rule.assign(connection, school, group.name(), basedn, 'workgroup')
				assignedGroups.append((group.name(), rule.name()))

			check2 = Check(school, assignedGroups)
			# check the assigned internet rules UMCP
			check2.checkRules(connection)

			# check ucr variables
			check2.checkUcr(ucr)

			# switch internetrules for groups randomly
			rules = newRules[4:]
			assignedGroups = []
			for group in newWorkgroups:
				rule = random.choice(rules)
				rule.assign(connection, school, group.name(), basedn, 'workgroup')
				assignedGroups.append((group.name(), rule.name()))

			check3 = Check(school, assignedGroups)

			# check the assigned internet rules UMCP
			check3.checkRules(connection)

			# check ucr variables
			check3.checkUcr(ucr)

			# assign default internetrule to groups
			for group in newWorkgroups:
				rule.assign(connection, school, group.name(), basedn, 'workgroup', default=True)

			# check the assigned internet rules UMCP
			check1.checkRules(connection)

			# check ucr variables
			check1.checkUcr(ucr)

			# Create random classs
			cIns = RandomClass()
			newclasses = cIns.createList(connection, school, 2)
			assignedClasses = [(c.name(),None) for c in newclasses]

			check1 = Check(school, assignedClasses)

			# check the assigned internet rules UMCP
			check1.checkRules(connection)

			# check ucr variables
			check1.checkUcr(ucr)

			# assign internetrules to classes randomly
			rules = newRules[:4]
			assignedClasses = []
			for c in newclasses:
				rule = random.choice(rules)
				rule.assign(connection, school, c.name(), basedn, 'class')
				assignedClasses.append((c.name(), rule.name()))

			check2 = Check(school, assignedClasses)

			# check the assigned internet rules UMCP
			check2.checkRules(connection)

			# check ucr variables
			check2.checkUcr(ucr)

			# switch internetrules for classes randomly
			rules = newRules[4:]
			assignedClasses = []
			for c in newclasses:
				rule = random.choice(rules)
				rule.assign(connection, school, c.name(), basedn, 'class')
				assignedClasses.append((c.name(), rule.name()))

			check3 = Check(school, assignedClasses)

			# check the assigned internet rules UMCP
			check3.checkRules(connection)

			# check ucr variables
			check3.checkUcr(ucr)

			# assign default internetrule to classes
			for c in newclasses:
				rule.assign(connection, school, c.name(), basedn, 'class', default=True)

			# check the assigned internet rules UMCP
			check1.checkRules(connection)

			# check ucr variables
			check1.checkUcr(ucr)

if __name__ == '__main__':
	sys.exit(main())
