#!/usr/share/ucs-test/runner python
## -*- coding: utf-8 -*-
## desc: Import users via CLI v2
## tags: [apptest,ucsschool,longrunning]
## roles: [domaincontroller_master]
## exposure: dangerous
## timeout: 14400
## packages:
##   - ucs-school-import

import tempfile
import json
import shutil
import logging
import copy
import sys
import random
import csv
import os
import pprint
import subprocess
import time
from essential.importusers import Person
import univention.testing.ucr
import univention.testing.udm
import univention.testing.strings as uts
import univention.testing.ucsschool as utu
import univention.testing.utils as utils


class Bunch(object):
	def __init__(self, **kwds):
		self.__dict__.update(kwds)


class ImportException(Exception):
	pass


class ConfigDict(dict):
	def update_entry(self, key, value):
		"""
		update_entry('foo:bar:baz', 'my value')
		update_entry('foo:bar:ding', False)
		"""
		if isinstance(value, basestring):
			if value.lower() == 'false':
				value = False
			elif value.lower() == 'true':
				value = True
		mydict = self
		items = key.split(':')
		while items:
			if len(items) == 1:
				mydict[items[0]] = value
			else:
				mydict = mydict.setdefault(items[0], {})
			del items[0]


class PyHooks(object):
	def __init__(self, hook_basedir=None):
		self.hook_basedir = hook_basedir if hook_basedir else '/usr/share/ucs-school-import/pyhooks'
		self.tmpdir = tempfile.mkdtemp(prefix='pyhook.', dir='/tmp')
		self.cleanup_files = set()
		self.log = logging.getLogger('PyHooks')

	def create_hooks(self):
		"""
		"""
		fn = '%s.py' % (uts.random_name(),)
		data = '''from ucsschool.importer.utils.user_pyhook import UserPyHook
import os

class MyHook(UserPyHook):
	priority = {
			"pre_create": 1,
			"post_create": 1,
			"pre_modify": 1,
			"post_modify": 1,
			"pre_move": 1,
			"post_move": 1,
			"pre_remove": 1,
			"post_remove": 1
	}

	def pre_create(self, user):
			self.logger.info("Running a pre_create hook for %%s.", user)
			self.run(user, 'create', 'pre')

	def post_create(self, user):
			self.logger.info("Running a post_create hook for %%s.", user)
			self.run(user, 'create', 'post')

	def pre_modify(self, user):
			self.logger.info("Running a pre_modify hook for %%s.", user)
			self.run(user, 'modify', 'pre')

	def post_modify(self, user):
			self.logger.info("Running a post_modify hook for %%s.", user)
			self.run(user, 'modify', 'post')

	def pre_move(self, user):
			self.logger.info("Running a pre_move hook for %%s.", user)
			self.run(user, 'move', 'pre')

	def post_move(self, user):
			self.logger.info("Running a post_move hook for %%s.", user)
			self.run(user, 'move', 'post')

	def pre_remove(self, user):
			self.logger.info("Running a pre_remove hook for %%s.", user)
			self.run(user, 'remove', 'pre')

	def post_remove(self, user):
			self.logger.info("Running a post_remove hook for %%s.", user)
			self.run(user, 'remove', 'post')

	def run(self, user, action, when):
		self.logger.info("***** Running {} {} hook for user {}.".format(when, action, user))
		# udm_properties[k] is only filled from LDAP, if k was in the input
		# don't try to get_udm_object() on a user not {anymore, yet} in ldap
		if not user.udm_properties.get('organisation') and not ((action == 'create' and when == 'pre') or (action == 'remove' and when == 'post')):
			obj = user.get_udm_object(self.lo)
			user.udm_properties['organisation'] = obj.info.get('organisation', '')
		user.udm_properties['organisation'] = user.udm_properties.get('organisation', '') + ',{}-{}'.format(when, action)
		if when == 'post' and action != 'remove':
			user.modify(self.lo)
		fn_touchfile = os.path.join(%(tmpdir)r, '%%s-%%s' %% (when, action))
		open(fn_touchfile, 'w').write('EXECUTED\\n')
''' % { 'tmpdir': self.tmpdir }

		fn = os.path.join(self.hook_basedir, fn)
		self.cleanup_files.add(fn)
		with open(fn, 'w') as fd:
			fd.write(data)
		self.log.info('Created hook %r', fn)

	def cleanup(self):
		shutil.rmtree(self.tmpdir, ignore_errors=True)
		for fn in self.cleanup_files:
			try:
				os.remove(fn)
			except (IOError, OSError):
				self.log.warning('Failed to remove %r' % (fn,))
			if fn.endswith('.py'):
				try:
					os.remove('%sc' % (fn,))  # also remove .pyc files
				except (IOError, OSError):
					pass


class CLI_Import_v2_Tester(object):
	def __init__(self):
		self.tmpdir = tempfile.mkdtemp(prefix='34_import-users_via_cli_v2.', dir='/tmp/')
		self.log = logging.getLogger('main')
		self.lo = None
		self.ldap_status = None
		self.hook_fn_set = set()
		self.ou_A = Bunch()
		self.ou_B = Bunch()
		self.ou_C = Bunch()
		self.default_config = ConfigDict({
			"factory": "ucsschool.importer.default_user_import_factory.DefaultUserImportFactory",
			"classes": {},
			"input": {
				"type": "csv",
				"filename": "import.csv"
			},
			"csv": {
				"mapping": {
					"OUs": "schools",
					"Vor": "firstname",
					"Nach": "lastname",
					"Gruppen": "school_classes",
					"E-Mail": "email",
					"Beschreibung": "description",
				}
			},
			"scheme": {
				"email": "<firstname>[0].<lastname>@<maildomain>",
				"recordUID": "<firstname>;<lastname>;<email>",
				"username": {
					"allow_rename": False,
					"default": "<:umlauts><firstname>[0].<lastname>[COUNTER2]"
				},
			},
			"sourceUID": "sourceDB",
			"user_role": "student",
			"tolerate_errors": 0,
		})

	def cleanup(self):
		self.log.info('Purging %r', self.tmpdir)
		shutil.rmtree(self.tmpdir, ignore_errors=True)
		for hook_fn in self.hook_fn_set:
			try:
				os.remove(hook_fn)
			except (IOError, OSError):
				self.log.warning('Failed to remove %r' % (hook_fn,))

	def create_config_json(self, values=None, config=None):
		"""
		Creates a config file for "ucs-school-user-import".
		Default values may be overridden via a dict called values.
		>>> values = {'user_role': 'teacher',
					  'input:type': 'csv' }
		>>> create_config_json(values=values)
		'/tmp/config.dkgfcsdz'
		>>> create_config_json(values=values, config=DEFAULT_CONFIG)
		'/tmp/config.dkgfcsdz'
		"""
		fn = tempfile.mkstemp(prefix='config.', dir=self.tmpdir)[1]
		if not config:
			config = copy.deepcopy(self.default_config)
		if values:
			for config_option, value in values.iteritems():
				config.update_entry(config_option, value)
		with open(fn, 'w') as fd:
			json.dump(config, fd)

		return fn

	def create_csv_file(self, person_list, mapping=None, fn_csv=None):
		"""
		Create CSV file for given persons
		>>> create_csv_file([Person('schoolA', 'student'), Person('schoolB', 'teacher')])
		'/tmp/import.sldfhgsg.csv'
		>>> create_csv_file([Person('schoolA', 'student'), Person('schoolB', 'teacher')], fn_csv='/tmp/import.foo.csv')
		'/tmp/import.foo.csv'
		>>> create_csv_file([Person('schoolA', 'student'), Person('schoolB', 'teacher')], headers={'firstname': 'Vorname', ...})
		'/tmp/import.cetjdfgj.csv'
		"""
		if mapping:
			header2properties = mapping
		else:
			header2properties = self.default_config['csv']['mapping']

		properties2headers = {v: k for k, v in header2properties.iteritems()}

		header_row = header2properties.keys()
		random.shuffle(header_row)
		self.log.debug('Header row = %r', header_row)

		fn = fn_csv if fn_csv else tempfile.mkstemp(prefix='users.', dir=self.tmpdir)[1]
		writer = csv.DictWriter(
			open(fn, 'w'),
			header_row,
			restval='',
			delimiter=',',
			quotechar='"',
			quoting=csv.QUOTE_ALL)
		writer.writeheader()
		for person in person_list:
			person_dict = person.map_to_dict(properties2headers)
			self.log.debug('Person data = %r', person_dict)
			writer.writerow(person_dict)
		return fn

	def save_ldap_status(self):
		self.log.debug('Saving LDAP status...')
		self.ldap_status = set(self.lo.searchDn())
		self.log.debug('LDAP status saved.')

	def diff_ldap_status(self):
		self.log.debug('Reading LDAP status for check differences...')
		new_ldap_status = set(self.lo.searchDn())
		new_objects = new_ldap_status - self.ldap_status
		removed_objects = self.ldap_status - new_ldap_status
		self.log.debug('LDAP status diffed.')
		self.log.debug('New objects: %r', new_objects)
		self.log.debug('Removed objects: %r', removed_objects)
		return Bunch(new=new_objects, removed=removed_objects)

	def run_import(self, args, fail_on_error=True):
		cmd = ['/usr/share/ucs-school-import/scripts/ucs-school-user-import'] + args
		self.log.info('Starting import: %r', cmd)
		sys.stdout.flush()
		sys.stderr.flush()
		exitcode = subprocess.call(cmd)
		self.log.info('Import process exited with exit code %r', exitcode)
		if fail_on_error and exitcode:
			self.log.error('As requested raising an exception due to non-zero exit code')
			raise ImportException('Non-zero exit code %r' % (exitcode,))
		return exitcode

	def check_num_users(self, exp_new, exp_removed):
		new_users = [x for x in self.diff_ldap_status().new if x.startswith('uid=')]
		if len(new_users) != exp_new:
			self.log.error('Invalid number of new users (expected %d, found %d)! Found new objects: %r',
				exp_new, len(new_users), new_users)
			utils.fail('Stopping because of invalid number of new users.')
		removed_users = [x for x in self.diff_ldap_status().removed if x.startswith('uid=')]
		if len(removed_users) != exp_removed:
			self.log.error('Invalid number of removed users (expected %d, found %d)! Removed objects: %r',
				exp_removed, len(removed_users), removed_users)
			utils.fail('Stopping because of invalid number of removed users.')

	def test_create_modify_delete_user(self):
		"""
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			import user with role <role>
			modify user with role <role> â†’ changing group memberships
			remove user with role <role>
		"""
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			self.log.info('*** Importing a new single user with role %r', role)

			person = Person(self.ou_A.name, role)
			fn_csv = self.create_csv_file(person_list=[person])
			source_uid = 'sourceUID-%s' % (uts.random_string(),)
			record_uid = '%s;%s;%s' % (person.firstname, person.lastname, person.mail)
			config = {
				'sourceUID': source_uid,
				'input:filename': fn_csv,
				'user_role': role,
			}
			fn_config = self.create_config_json(values=config)
			# save ldap state for later comparison
			self.save_ldap_status()

			# start import
			self.run_import(['-c', fn_config])

			# check for new users in LDAP
			self.check_num_users(1, 0)

			# update dn+username of person and verify LDAP attributes
			new_users = [x for x in self.diff_ldap_status().new if x.startswith('uid=')]
			person.update(dn=new_users[0], record_uid=record_uid, source_uid=source_uid)
			person.verify()


			self.log.info('*** Modifying a single user with role %r', role)

			if role == 'student':
				person.school_classes = {}
			if role in ('student', 'teacher', 'teacher_and_staff'):
				person.append_random_class()

			self.create_csv_file(person_list=[person], fn_csv=fn_csv)
			fn_config = self.create_config_json(values=config)
			# save ldap state for later comparison
			self.save_ldap_status()

			# start import
			self.run_import(['-c', fn_config])

			# check for new users in LDAP
			self.check_num_users(0, 0)

			# verify LDAP attributes
			person.verify()

			self.log.info('*** Remove a single user with role %r', role)

			# mark person as removed
			person.set_mode_to_delete()
			self.create_csv_file(person_list=[], fn_csv=fn_csv)
			fn_config = self.create_config_json(values=config)
			# save ldap state for later comparison
			self.save_ldap_status()

			# start import
			self.run_import(['-c', fn_config])

			# check for new users in LDAP
			self.check_num_users(0, 1)

			# verify LDAP attributes
			person.verify()

		self.log.info('Creating, modifying, removing user with role %r was successful', role)
		self.log.info('Test was successful.\n\n\n')



	def test_create_modify_delete_user_with_username_and_recordUID_and_UDM_property(self):
		"""
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			import user with role <role> and given username
			remove user with role <role> and given username
		"""
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			hooks = PyHooks()
			hooks.create_hooks()
			try:
				self.log.info('*** Importing a new single user with role %r and username and recordUID', role)

				source_uid = 'sourceUID-%s' % (uts.random_string(),)
				record_uid_A = uts.random_name()
				record_uid_B = uts.random_name()

				config = copy.deepcopy(self.default_config)
				config.update_entry('sourceUID', source_uid)
				config.update_entry('csv:mapping:Benutzername', 'username')
				config.update_entry('csv:mapping:DBID', 'record_uid')
				config.update_entry('user_role', role)

				person_list = [Person(self.ou_A.name, role), Person(self.ou_A.name, role)]
				person_list[0].update(record_uid=record_uid_A, source_uid=source_uid, description=uts.random_name())
				person_list[1].update(record_uid=record_uid_B, source_uid=source_uid, description=uts.random_name())
				fn_csv = self.create_csv_file(person_list=person_list, mapping=config['csv']['mapping'])
				config.update_entry('input:filename', fn_csv)
				fn_config = self.create_config_json(config=config)
				# save ldap state for later comparison
				self.save_ldap_status()

				# start import
				self.run_import(['-c', fn_config, '-i', fn_csv])

				# check for new users in LDAP
				self.check_num_users(2, 0)

				# update dn+username of person and verify LDAP attributes
				for person in person_list:
					person.verify()
				utils.verify_ldap_object(person.dn, expected_attr={'o': [',pre-create,post-create']}, strict=True, should_exist=True)

				def assert_and_print(exists, fn):
					status = os.path.exists(os.path.join(hooks.tmpdir, fn))
					self.log.debug('Hook touch file %r exists = %r' % (fn, status))
					assert exists == status, 'Unexpected status of hook touch file: exists=%s  expected=%s' % (status, exists)

				for fn in ('pre-create', 'post-create'):
					assert_and_print(True, fn)
				for fn in ('pre-modify', 'post-modify', 'pre-remove', 'post-remove'):
					assert_and_print(False, fn)

				self.log.info('*** Modifying a single user with role %r and username and recordUID', role)

				person_list[0].firstname = uts.random_name()
				person_list[1].lastname = uts.random_name()
				self.create_csv_file(person_list=person_list, mapping=config['csv']['mapping'], fn_csv=fn_csv)
				fn_config = self.create_config_json(values=config)
				# save ldap state for later comparison
				self.save_ldap_status()
				# start import
				self.run_import(['-c', fn_config, '-i', fn_csv])
				# check for new users in LDAP
				self.check_num_users(0, 0)

				# verify LDAP attributes
				for person in person_list:
					person.verify()
				utils.verify_ldap_object(person.dn, expected_attr={'o': [',pre-create,post-create,pre-modify,post-modify']}, strict=True, should_exist=True)
				for fn in ('pre-create', 'post-create', 'pre-modify', 'post-modify'):
					assert_and_print(True, fn)
				for fn in ('pre-remove', 'post-remove'):
					assert_and_print(False, fn)


				self.log.info('*** Remove a single user with role %r and username and recordUID', role)

				# mark first person as removed
				person_list[0].set_mode_to_delete()
				self.create_csv_file(person_list=[person_list[1]], mapping=config['csv']['mapping'], fn_csv=fn_csv)
				fn_config = self.create_config_json(values=config)
				# save ldap state for later comparison
				self.save_ldap_status()

				# start import
				self.run_import(['-c', fn_config, '-i', fn_csv])

				# check for new users in LDAP
				self.check_num_users(0, 1)

				# verify LDAP attributes
				for person in person_list:
					person.verify()
				for fn in ('pre-create', 'post-create', 'pre-modify', 'post-modify', 'pre-remove', 'post-remove'):
					assert_and_print(True, fn)

			finally:
				hooks.cleanup()
		self.log.info('Creating, modifying, removing user with role %r and username/recordUID was successful', role)
		self.log.info('Test was successful.\n\n\n')


	def test_create_with_username_scheme(self):
		"""
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			import user with role <role> and special username scheme
		"""
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			self.log.info('*** Importing a new single user with role %r and username and recordUID', role)

			source_uid = 'sourceUID-%s' % (uts.random_string(),)
			record_uid = uts.random_name()

			config = copy.deepcopy(self.default_config)
			config.update_entry('sourceUID', source_uid)
			config.update_entry('csv:mapping:DBID', 'record_uid')
			config.update_entry('scheme:recordUID', '<record_uid>')
			config.update_entry('user_role', role)
			config.update_entry('scheme:username:default', "<:umlauts>user-<firstname>[0:2].<lastname>[0:2]-[ALWAYSCOUNTER]")

			person = Person(self.ou_A.name, role)
			person.update(record_uid=record_uid, source_uid=source_uid, username=None)
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			config.update_entry('input:filename', fn_csv)
			fn_config = self.create_config_json(config=config)
			# save ldap state for later comparison
			self.save_ldap_status()

			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv])

			# check for new users in LDAP
			self.check_num_users(1, 0)

			# update dn+username of person and verify LDAP attributes
			new_users = [x for x in self.diff_ldap_status().new if x.startswith('uid=')]
			person.update(dn=new_users[0], record_uid=record_uid, source_uid=source_uid)
			person.verify()

			username_prefix = 'user-%s.%s-' % (person.firstname[0:2], person.lastname[0:2])
			if person.username.rstrip('0123456789') != username_prefix:
				utils.fail('username %r does not start with expected string %r' % (person.username, username_prefix))
			self.log.info('Username %r starts as expected with string %r' % (person.username, username_prefix))

			# check if username history object exists
			self.log.info('Checking for unique-usernames object...')
			dn = 'cn=%s,cn=unique-usernames,cn=ucsschool,cn=univention,%s' % (username_prefix, self.lo.base)
			attrs = {
				'objectClass': ['ucsschoolUsername'],
				'ucsschoolUsernameNextNumber': ['2'],
				'cn': [username_prefix],
			}
			utils.verify_ldap_object(dn, expected_attr=attrs, strict=True, should_exist=True)
			self.log.debug('User object %r:\n%s', dn, pprint.PrettyPrinter(indent=2).pformat(self.lo.get(dn)))
			self.log.info('unique-usernames object has been found.')
			self.log.info('Test was successful.\n\n\n')

	def test_create_modify_only(self):
		"""
		check if the --no-delete option works as expected
		"""
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			self.log.info('*** Add/modify without delete with role %r', role)

			source_uid = 'sourceUID-%s' % (uts.random_string(),)
			config = copy.deepcopy(self.default_config)
			config.update_entry('csv:mapping:Benutzername', 'username')
			config.update_entry('scheme:recordUID', '<username>')
			config.update_entry('sourceUID', source_uid)
			config.update_entry('user_role', role)
			personA = Person(self.ou_A.name, role)
			personB = Person(self.ou_A.name, role)

			self.log.info('Adding user A %r with role %r', personA.username, role)
			fn_csv = self.create_csv_file(person_list=[personA], mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(values=config)
			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv, '--no-delete'])

			userlist = self.lo.searchDn('uid=%s' % (personA.username,))
			if len(userlist) != 1:
				self.log.error('Invalid number of users for personA! Found new objects: %r', userlist)
				utils.fail('Stopping here')
			personA.verify()

			self.log.info('Adding user B %r with role %r', personB.username, role)
			fn_csv = self.create_csv_file(person_list=[personB], mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(values=config)
			self.run_import(['-c', fn_config, '-i', fn_csv, '--no-delete'])

			for username in (personA.username, personB.username):
				userlist = self.lo.searchDn('uid=%s' % (username,))
				if len(userlist) != 1:
					self.log.error('Invalid number of user objects for user %r! Found new objects: %r', username, userlist)
					utils.fail('Stopping here')
			personA.verify()
			personB.verify()

			self.log.info('Modifying user A %r with role %r', personA.username, role)
			personA.lastname = uts.random_name()
			config.update_entry('no_delete', 'True')
			fn_csv = self.create_csv_file(person_list=[personA], mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(values=config)
			self.run_import(['-c', fn_config, '-i', fn_csv])  #  '--no-delete'  is not specified on purpose -> using config option "no_delete"

			for username in (personA.username, personB.username):
				userlist = self.lo.searchDn('uid=%s' % (username,))
				if len(userlist) != 1:
					self.log.error('Invalid number of user objects for user %r! Found new objects: %r', username, userlist)
					utils.fail('Stopping here')
			personA.verify()
			personB.verify()
		self.log.info('Test was successful.\n\n\n')

	def test_create_with_attribute_schemes(self):
		"""
		Create a new user for each role:
		- use UDM template syntax (http://docs.software-univention.de/handbuch-4.1.html#users:templates)
          to define several custom values
        - employeeNumber is filled with a string consisting of first and last name and description
        - mailPrimaryAddress is also built from those attributes
		"""
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			self.log.info('*** Importing a new single user with role %r from templates', role)

			source_uid = 'sourceUID-%s' % (uts.random_string(),)
			record_uid = uts.random_name()

			config = copy.deepcopy(self.default_config)
			config.update_entry('sourceUID', source_uid)
			config.update_entry('csv:mapping:employeeNumber', 'employeeNumber')
			config.update_entry('csv:mapping:DBID', 'record_uid')
			config.update_entry('scheme:recordUID', '<record_uid>')
			config.update_entry('user_role', role)
			config.update_entry('scheme:username:default', "<:umlauts>user-<firstname>[0:2].<lastname>[0:2]-[ALWAYSCOUNTER]")
			config.update_entry('scheme:email', "<:umlauts><firstname:lower>[0:3].<lastname:lower>[2:5]@example.com")
			config.update_entry('scheme:employeeNumber', "The user's name is <firstname:upper> <lastname> <description>")

			person = Person(self.ou_A.name, role)
			person.update(record_uid=record_uid, source_uid=source_uid, username=None, mail=None, description=uts.random_name())
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(config=config)
			# save ldap state for later comparison
			self.save_ldap_status()

			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv])

			# check for new users in LDAP
			new_users = [x for x in self.diff_ldap_status().new if x.startswith('uid=')]
			if len(new_users) != 1:
				self.log.error('Invalid number of new users! Found new objects: %r', new_users)
				utils.fail('Stopping here')

			# update dn+username of person and verify LDAP attributes
			mail = '%s.%s@example.com' % (person.firstname[0:3].lower(), person.lastname[2:5].lower())
			person.update(dn=new_users[0], record_uid=record_uid, source_uid=source_uid, mail=mail)
			person.verify()

			username_prefix = 'user-%s.%s-' % (person.firstname[0:2], person.lastname[0:2])
			if person.username.rstrip('0123456789') != username_prefix:
				utils.fail('username %r does not start with expected string %r' % (person.username, username_prefix))
			self.log.info('Username %r starts as expected with string %r' % (person.username, username_prefix))

			self.log.info('Testing mailPrimaryAddress and description...')
			values = {
				'employeeNumber': ["The user's name is %s %s %s" % (person.firstname.upper(), person.lastname, person.description)],
			}
			utils.verify_ldap_object(person.dn, expected_attr=values, strict=True, should_exist=True)
			self.log.debug('User object %r:\n%s', person.dn, pprint.PrettyPrinter(indent=2).pformat(self.lo.get(person.dn)))
		self.log.info('Test was successful.\n\n\n')


	def test_multivalue_attributes(self):
		"""
		Create/modify a new user for each role:
        - mailAlternativeAddress is filled with multiple strings
		"""
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			self.log.info('*** Importing a new single user with role %r with multivalue attributes', role)

			source_uid = 'sourceUID-%s' % (uts.random_string(),)

			config = copy.deepcopy(self.default_config)
			config.update_entry('sourceUID', source_uid)
			config.update_entry('csv:incell-delimiter:default', ';')
			config.update_entry('csv:mapping:Benutzername', 'username')
			config.update_entry('csv:mapping:recordUID', 'record_uid')
			config.update_entry('csv:mapping:mailAlternativeAddress', 'mailAlternativeAddress')
			config.update_entry('scheme:recordUID', '<username>')
			config.update_entry('sourceUID', source_uid)
			config.update_entry('user_role', role)

			class MultiPerson(Person):
				def __init__(self, school, role):
					Person.__init__(self, school, role)
					self.mailAlternativeAddress = '%s@example.com;%s@example.com;%s@example.com' % (uts.random_name(), uts.random_name(), uts.random_name())

				def map_to_dict(self, value_map):
					result = Person.map_to_dict(self, value_map)
					result[value_map.get('mailAlternativeAddress', '__EMPTY__')] = self.mailAlternativeAddress
					return result

				def expected_attributes(self):
					result = Person.expected_attributes(self)
					result['mailAlternativeAddress'] = self.mailAlternativeAddress.split(',')


			# create person with 3 alternative mail addresses
			person = MultiPerson(self.ou_A.name, role)
			person.update(record_uid=person.username, source_uid=source_uid)
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(config=config)
			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv])

			self.log.debug('User object %r:\n%s', person.dn, pprint.PrettyPrinter(indent=2).pformat(self.lo.get(person.dn)))
			person.verify()

			# modify person and set 1 alternative mail address
			person.update(mailAlternativeAddress='%s@example.com' % (uts.random_name(),))
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(config=config)
			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv])

			self.log.debug('User object %r:\n%s', person.dn, pprint.PrettyPrinter(indent=2).pformat(self.lo.get(person.dn)))
			person.verify()
		self.log.info('Test was successful.\n\n\n')

	def test_school_change(self):
		"""
		Create/modify a new user for each role:
        - mailAlternativeAddress is filled with multiple strings
		"""
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			self.log.info('*** Importing a new single user with role %r and change school afterwards', role)

			source_uid = 'sourceUID-%s' % (uts.random_string(),)

			config = copy.deepcopy(self.default_config)
			config.update_entry('sourceUID', source_uid)
			config.update_entry('csv:mapping:Benutzername', 'username')
			config.update_entry('csv:mapping:recordUID', 'record_uid')
			config.update_entry('scheme:recordUID', '<username>')
			config.update_entry('sourceUID', source_uid)
			config.update_entry('user_role', role)

			# create person in school A
			person = Person(self.ou_A.name, role)
			person.update(record_uid=person.username, source_uid=source_uid)
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(config=config)
			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv])

			self.log.debug('User object %r:\n%s', person.dn, pprint.PrettyPrinter(indent=2).pformat(self.lo.get(person.dn)))
			person.verify()

			# move person to school B
			person.update(school=self.ou_B.name)
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(config=config)
			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv])

			userlist = self.lo.searchDn('uid=%s' % (person.username,))
			if len(userlist) != 1:
				self.log.error('Invalid number of user objects for user %r! Found new objects: %r', person.username, userlist)
				utils.fail('Stopping here')

			person.update(dn=userlist[0])
			self.log.debug('User object %r:\n%s', person.dn, pprint.PrettyPrinter(indent=2).pformat(self.lo.get(person.dn)))
			person.verify()

		self.log.info('Test was successful.\n\n\n')

	def test_lowercase_username_with_counter(self):
		"""
		Bug #41645: a username scheme with <:lower> and [COUNTER2]
		"""

		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			self.log.info('*** Importing a new single user with role %r from templates', role)

			source_uid = 'sourceUID-%s' % (uts.random_string(),)
			record_uid = uts.random_name()

			config = copy.deepcopy(self.default_config)
			config.update_entry('sourceUID', source_uid)
			config.update_entry('csv:mapping:employeeNumber', 'employeeNumber')
			config.update_entry('csv:mapping:DBID', 'record_uid')
			config.update_entry('scheme:recordUID', '<record_uid>')
			config.update_entry('user_role', role)
			config.update_entry('scheme:username:default', "<:lower><:umlauts><firstname>[0:6].<lastname>[0:3]a[COUNTER2]")
			config.update_entry('scheme:email', "<:umlauts><firstname:lower>.<lastname:lower>@example.com")
			config.update_entry('scheme:employeeNumber', "The user's name is <firstname:upper> <lastname> <description>")

			person = Person(self.ou_A.name, role)
			person.update(record_uid=record_uid, source_uid=source_uid, username=None, mail=None, description=uts.random_name())
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(config=config)
			# save ldap state for later comparison
			self.save_ldap_status()

			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv])

			# check for new users in LDAP
			new_users = [x for x in self.diff_ldap_status().new if x.startswith('uid=')]
			if len(new_users) != 1:
				self.log.error('Invalid number of new users! Found new objects: %r', new_users)
				utils.fail('Stopping here')

			# update dn+username of person and verify LDAP attributes
			mail = '%s.%s@example.com' % (person.firstname.lower(), person.lastname.lower())
			person.update(dn=new_users[0], record_uid=record_uid, source_uid=source_uid, mail=mail)
			person.verify()

			username_prefix = '%s.%sa' % (person.firstname[0:6], person.lastname[0:3])
			if person.username.rstrip('0123456789') != username_prefix:
				utils.fail('username %r does not start with expected string %r' % (person.username, username_prefix))
			self.log.info('Username %r starts as expected with string %r' % (person.username, username_prefix))

			self.log.info('Testing mailPrimaryAddress and description...')
			values = {
				'employeeNumber': ["The user's name is %s %s %s" % (person.firstname.upper(), person.lastname, person.description)],
			}
			utils.verify_ldap_object(person.dn, expected_attr=values, strict=True, should_exist=True)
			self.log.debug('User object %r:\n%s', person.dn, pprint.PrettyPrinter(indent=2).pformat(self.lo.get(person.dn)))
		self.log.info('Test was successful.\n\n\n')

	def test_iso_birthday(self):
		"""
		Bug #41642: Create/modify a new user for each role:
        - set ISO birthday (2016-06-23) for each user type
		"""
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			self.log.info('*** Importing a new single user with role %r with multivalue attributes', role)

			source_uid = 'sourceUID-%s' % (uts.random_string(),)

			config = copy.deepcopy(self.default_config)
			config.update_entry('sourceUID', source_uid)
			config.update_entry('csv:incell-delimiter:default', ';')
			config.update_entry('csv:mapping:Benutzername', 'username')
			config.update_entry('csv:mapping:recordUID', 'record_uid')
			config.update_entry('csv:mapping:birthday', 'birthday')
			config.update_entry('scheme:recordUID', '<username>')
			config.update_entry('sourceUID', source_uid)
			config.update_entry('user_role', role)

			class BirthdayPerson(Person):
				def __init__(self, school, role):
					Person.__init__(self, school, role)
					self.birthday = time.strftime('%Y-%m-%d')

				def map_to_dict(self, value_map):
					result = Person.map_to_dict(self, value_map)
					result[value_map.get('birthday', '__EMPTY__')] = self.birthday
					return result

				def expected_attributes(self):
					result = Person.expected_attributes(self)
					result['birthday'] = [self.birthday]

			# create person with ISO birthday (today)
			person = BirthdayPerson(self.ou_A.name, role)
			person.update(record_uid=person.username, source_uid=source_uid)
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(config=config)
			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv])

			self.log.debug('User object %r:\n%s', person.dn, pprint.PrettyPrinter(indent=2).pformat(self.lo.get(person.dn)))
			person.verify()

			# modify person and set birthday to new year's day
			person.update(birthday='2016-01-01')
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(config=config)
			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv])

			self.log.debug('User object %r:\n%s', person.dn, pprint.PrettyPrinter(indent=2).pformat(self.lo.get(person.dn)))
			person.verify()
		self.log.info('Test was successful.\n\n\n')


	def test_create_modify_with_extended_attribute(self, udm):
		"""
		Bug #41707: set values in extended attribute
		"""

		ext_attr_name = uts.random_name()
		properties = {
			'position': udm.UNIVENTION_CONTAINER,
			'name': uts.random_name(),
			'shortDescription': uts.random_string(),
			'CLIName': ext_attr_name,
			'module': 'users/user',
			'objectClass': 'univentionFreeAttributes',
			'ldapMapping': 'univentionFreeAttribute15'
		}
		extended_attribute = udm.create_object('settings/extended_attribute', **properties)

		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			self.log.info('*** Importing a new single user with role %r with ', role)

			source_uid = 'sourceUID-%s' % (uts.random_string(),)

			config = copy.deepcopy(self.default_config)
			config.update_entry('sourceUID', source_uid)
			config.update_entry('csv:mapping:extattr', ext_attr_name)
			config.update_entry('csv:mapping:Benutzername', 'username')
			config.update_entry('csv:mapping:recordUID', 'record_uid')
			config.update_entry('scheme:recordUID', '<username>')
			config.update_entry('scheme:%s' % (ext_attr_name,), "<firstname:upper> <lastname> <description>")
			config.update_entry('sourceUID', source_uid)
			config.update_entry('user_role', role)

			class ExtAttrPerson(Person):
				def __init__(self, school, role):
					Person.__init__(self, school, role)
					self.extattr = time.strftime('%Y-%m-%d')

				def map_to_dict(self, value_map):
					result = Person.map_to_dict(self, value_map)
					result[value_map.get(ext_attr_name, '__EMPTY__')] = self.extattr
					return result

				def expected_attributes(self):
					result = Person.expected_attributes(self)
					result['univentionFreeAttributes15'] = [self.extattr]

			# create person with extended attribute (today)
			person = ExtAttrPerson(self.ou_A.name, role)
			person.update(record_uid=person.username, source_uid=source_uid)
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(config=config)
			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv])

			self.log.debug('User object %r:\n%s', person.dn, pprint.PrettyPrinter(indent=2).pformat(self.lo.get(person.dn)))
			person.verify()

			# modify person and set ext_attr to random value
			person.update(extattr=uts.random_string())
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(config=config)
			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv])

			self.log.debug('User object %r:\n%s', person.dn, pprint.PrettyPrinter(indent=2).pformat(self.lo.get(person.dn)))
			person.verify()
		self.log.info('Test was successful.\n\n\n')

	def test_create_with_empty_class_name(self):
		"""
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			import user with role <role> and empty class name
		"""
		first_user = True
		config = copy.deepcopy(self.default_config)
		source_uid = 'sourceUID-%s' % (uts.random_string(),)
		config.update_entry('sourceUID', source_uid)

		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			self.log.info('*** Importing a new single user with role %r and empty class name.', role)

			config.update_entry('user_role', role)

			person = Person(self.ou_A.name, role)
			person.update(school_classes={})
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			config.update_entry('input:filename', fn_csv)
			fn_config = self.create_config_json(config=config)
			# save ldap state for later comparison
			self.save_ldap_status()

			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv])

			# check for new users in LDAP
			if first_user:
				num_rem = 0
				first_user = False
			else:
				num_rem = 1
			self.check_num_users(1, num_rem)

			self.log.info('Test was successful.\n\n\n')

	def test_no_delete_option(self):
		"""
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			import user with role <role> and [un]set --no-delete option
		"""
		config = copy.deepcopy(self.default_config)
		source_uid = 'sourceUID-%s' % (uts.random_string(),)
		config.update_entry('sourceUID', source_uid)

		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			self.log.info('*** Testing "--no-delete" option for role %r.', role)

			config.update_entry('user_role', role)

			person = Person(self.ou_A.name, role)
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			config.update_entry('input:filename', fn_csv)
			fn_config = self.create_config_json(config=config)
			# save ldap state for later comparison
			self.save_ldap_status()

			# start import
			self.log.info('*** Importing a user')
			self.run_import(['-c', fn_config, '-i', fn_csv])

			# check for new users in LDAP
			self.check_num_users(1, 0)

			self.log.info('*** Importing a user, NOT deleting previous user (running with "--no-delete")')
			person = Person(self.ou_A.name, role)
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			self.save_ldap_status()
			self.run_import(['-c', fn_config, '-i', fn_csv, '--no-delete'])

			# check for new users in LDAP
			self.check_num_users(1, 0)

			self.log.info('*** Importing a user, deleting previous two users (running without "--no-delete")')
			person = Person(self.ou_A.name, role)
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			self.save_ldap_status()
			self.run_import(['-c', fn_config, '-i', fn_csv])

			# check for new users in LDAP
			self.check_num_users(1, 2)

			self.log.info('*** Importing a user, deleting previous user')
			person = Person(self.ou_A.name, role)
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			self.save_ldap_status()
			self.run_import(['-c', fn_config, '-i', fn_csv])

			# check for new users in LDAP
			self.check_num_users(1, 1)

			self.log.info('*** Importing same user and running with "--no-delete"')
			person.set_mode_to_delete()
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			self.save_ldap_status()
			self.run_import(['-c', fn_config, '-i', fn_csv, '--no-delete'])

			# check for new users in LDAP
			self.check_num_users(0, 0)

			self.log.info('*** Importing same user with action="D" and running with "--no-delete"')
			person.set_mode_to_delete()
			config_d = copy.deepcopy(config)
			config_d.update_entry('csv:mapping:Aktion', '__action')
			fn_config_d = self.create_config_json(config=config_d)
			fn_csv = self.create_csv_file(person_list=[person], mapping=config_d['csv']['mapping'])
			self.save_ldap_status()
			self.run_import(['-c', fn_config_d, '-i', fn_csv, '--no-delete'])

			# check for new users in LDAP
			self.check_num_users(0, 1)

			self.log.info('Test was successful.\n\n\n')

	def test_modify_with_several_groups(self, udm):
		"""
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			- create user with 2 schools
			- add user to several groups: global group; workgroup, class, extra group for each school
			- modify user with role <role>
			- remove user with role <role>
		"""
		global_group_dn, global_group_name = udm.create_group()
		workgroup_A_dn, workgroup_A_name = udm.create_group(position='cn=schueler,cn=groups,%s' % (self.ou_A.dn,))
		cn_A_dn = udm.create_object('container/cn', position=self.ou_A.dn, name='kurs-%s' % uts.random_string())
		extra_A_group_dn, extra_A_group_name = udm.create_group(position=cn_A_dn)
		workgroup_B_dn, workgroup_B_name = udm.create_group(position='cn=schueler,cn=groups,%s' % (self.ou_B.dn,))
		cn_B_dn = udm.create_object('container/cn', position=self.ou_B.dn, name='kurs-%s' % uts.random_string())
		extra_B_group_dn, extra_B_group_name = udm.create_group(position=cn_B_dn)

		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			self.log.info('*** Importing a new single user with role %r', role)

			# create user that is member in multiple schools
			person = Person(self.ou_A.name, role)
			person.update(schools=[self.ou_A.name, self.ou_B.name])
			if role in ('student', 'teacher', 'teacher_and_staff'):
				person.append_random_class(schools=[person.school])  # TODO FIXME Bug #41914: line should be: person.append_random_class(schools=person.schools)

			fn_csv = self.create_csv_file(person_list=[person])
			source_uid = 'sourceUID-%s' % (uts.random_string(),)
			record_uid = '%s;%s;%s' % (person.firstname, person.lastname, person.mail)
			config = {
				'sourceUID': source_uid,
				'input:filename': fn_csv,
				'user_role': role,
			}
			fn_config = self.create_config_json(values=config)
			# save ldap state for later comparison
			self.save_ldap_status()

			# start import
			self.run_import(['-c', fn_config])

			# check for new users in LDAP
			self.check_num_users(1, 0)

			# update dn+username of person and verify LDAP attributes
			new_users = [x for x in self.diff_ldap_status().new if x.startswith('uid=')]
			user_dn = new_users[0]
			person.update(dn=user_dn, record_uid=record_uid, source_uid=source_uid)
			person.verify()

			self.log.info('*** Adding user with role %r to groups', role)

			# add user to working groups, extra groups in both schools and to global group
			udm.modify_object('groups/group', dn=global_group_dn, append={'users': [user_dn]})
			udm.modify_object('groups/group', dn=workgroup_A_dn, append={'users': [user_dn]})
			udm.modify_object('groups/group', dn=workgroup_B_dn, append={'users': [user_dn]})
			udm.modify_object('groups/group', dn=extra_A_group_dn, append={'users': [user_dn]})
			udm.modify_object('groups/group', dn=extra_B_group_dn, append={'users': [user_dn]})
			utils.verify_ldap_object(global_group_dn, expected_attr={'uniqueMember': [user_dn]}, strict=False, should_exist=True)
			utils.verify_ldap_object(workgroup_A_dn, expected_attr={'uniqueMember': [user_dn]}, strict=False, should_exist=True)
			utils.verify_ldap_object(extra_A_group_dn, expected_attr={'uniqueMember': [user_dn]}, strict=False, should_exist=True)
			utils.verify_ldap_object(workgroup_B_dn, expected_attr={'uniqueMember': [user_dn]}, strict=False, should_exist=True)
			utils.verify_ldap_object(extra_B_group_dn, expected_attr={'uniqueMember': [user_dn]}, strict=False, should_exist=True)

			self.log.info('*** Modifying a single user with role %r', role)

			person.school_classes = {}
			if role in ('student', 'teacher', 'teacher_and_staff'):
				person.append_random_class(schools=[person.school])  # TODO FIXME Bug #41914: line should be: person.append_random_class(schools=person.schools)

			self.create_csv_file(person_list=[person], fn_csv=fn_csv)
			fn_config = self.create_config_json(values=config)
			# save ldap state for later comparison
			self.save_ldap_status()

			# start import
			self.run_import(['-c', fn_config])

			# check for new users in LDAP
			self.check_num_users(0, 0)

			# verify LDAP attributes
			person.verify()
			utils.verify_ldap_object(global_group_dn, expected_attr={'uniqueMember': [user_dn]}, strict=False, should_exist=True)
			utils.verify_ldap_object(workgroup_A_dn, expected_attr={'uniqueMember': [user_dn]}, strict=False, should_exist=True)
			utils.verify_ldap_object(extra_A_group_dn, expected_attr={'uniqueMember': [user_dn]}, strict=False, should_exist=True)
			utils.verify_ldap_object(workgroup_B_dn, expected_attr={'uniqueMember': [user_dn]}, strict=False, should_exist=True)
			utils.verify_ldap_object(extra_B_group_dn, expected_attr={'uniqueMember': [user_dn]}, strict=False, should_exist=True)

			self.log.info('*** Remove a single user with role %r', role)

			# mark person as removed
			person.set_mode_to_delete()
			self.create_csv_file(person_list=[], fn_csv=fn_csv)
			fn_config = self.create_config_json(values=config)
			# save ldap state for later comparison
			self.save_ldap_status()

			# start import
			self.run_import(['-c', fn_config])

			# check for new users in LDAP
			self.check_num_users(0, 1)

			# verify LDAP attributes
			person.verify()

		self.log.info('Creating, modifying, removing user with role %r was successful', role)
		self.log.info('Test was successful.\n\n\n')

	def run(self):
		try:
			ucr = univention.testing.ucr.UCSTestConfigRegistry()
			ucr.load()

			with univention.testing.udm.UCSTestUDM() as udm:
				with utu.UCSTestSchool() as schoolenv:
					self.ou_A.name, self.ou_A.dn = schoolenv.create_ou(name_edudc=ucr.get('hostname'))
					self.ou_B.name, self.ou_B.dn = schoolenv.create_ou(name_edudc=ucr.get('hostname'))
					self.ou_C.name, self.ou_C.dn = schoolenv.create_ou(name_edudc=ucr.get('hostname'))
					self.lo = schoolenv.open_ldap_connection(admin=True)

					self.test_create_modify_delete_user()
					self.test_create_modify_delete_user_with_username_and_recordUID_and_UDM_property()
					self.test_create_with_username_scheme()
					self.test_create_modify_only()
					self.test_create_with_attribute_schemes()
					self.test_multivalue_attributes()
					self.test_school_change()
					self.test_iso_birthday()
					self.test_lowercase_username_with_counter()
					self.test_create_modify_with_extended_attribute(udm)
					self.test_create_with_empty_class_name()
					self.test_no_delete_option()
					self.test_modify_with_several_groups(udm)
		finally:
			self.cleanup()

def main():
	logging.basicConfig(stream=sys.stdout, level=logging.DEBUG, format='%(levelname)s: %(funcName)s:%(lineno)d: %(message)s')
	tester = CLI_Import_v2_Tester()
	tester.run()


if __name__ == '__main__':
	main()
