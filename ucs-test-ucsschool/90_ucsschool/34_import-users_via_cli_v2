#!/usr/share/ucs-test/runner python
## -*- coding: utf-8 -*-
## desc: Import users via CLI v2
## tags: [apptest,ucsschool,longrunning]
## roles: [domaincontroller_master]
## exposure: dangerous
## timeout: 14400
## packages:
##   - ucs-school-import
## bugs: [41243, 41244, 41344, 41346, 41350, 41354, 41471, 41472, 41544, 41609, 41642, 41645, 41707, 41775, 41847, 41857, 41907]

import tempfile
import json
import shutil
import logging
import copy
import sys
import random
import csv
import os
import pprint
import subprocess
import time
import string
import re
import datetime
from essential.importusers import Person
import univention.testing.ucr
import univention.testing.udm
import univention.testing.strings as uts
import univention.testing.ucsschool as utu
import univention.testing.utils as utils


class Bunch(object):
	def __init__(self, **kwds):
		self.__dict__.update(kwds)


class ImportException(Exception):
	pass


class ConfigDict(dict):
	def update_entry(self, key, value):
		"""
		update_entry('foo:bar:baz', 'my value')
		update_entry('foo:bar:ding', False)
		"""
		if isinstance(value, basestring):
			if value.lower() == 'false':
				value = False
			elif value.lower() == 'true':
				value = True
		mydict = self
		items = key.split(':')
		while items:
			if len(items) == 1:
				mydict[items[0]] = value
			else:
				mydict = mydict.setdefault(items[0], {})
			del items[0]


class PyHooks(object):
	def __init__(self, hook_basedir=None):
		self.hook_basedir = hook_basedir if hook_basedir else '/usr/share/ucs-school-import/pyhooks'
		self.tmpdir = tempfile.mkdtemp(prefix='pyhook.', dir='/tmp')
		self.cleanup_files = set()
		self.log = logging.getLogger('PyHooks')

	def create_hooks(self):
		"""
		"""
		fn = '%s.py' % (uts.random_name(),)
		data = '''from ucsschool.importer.utils.user_pyhook import UserPyHook
import os

class MyHook(UserPyHook):
	priority = {
			"pre_create": 1,
			"post_create": 1,
			"pre_modify": 1,
			"post_modify": 1,
			"pre_move": 1,
			"post_move": 1,
			"pre_remove": 1,
			"post_remove": 1
	}

	def pre_create(self, user):
			self.logger.info("Running a pre_create hook for %%s.", user)
			self.run(user, 'create', 'pre')

	def post_create(self, user):
			self.logger.info("Running a post_create hook for %%s.", user)
			self.run(user, 'create', 'post')

	def pre_modify(self, user):
			self.logger.info("Running a pre_modify hook for %%s.", user)
			self.run(user, 'modify', 'pre')

	def post_modify(self, user):
			self.logger.info("Running a post_modify hook for %%s.", user)
			self.run(user, 'modify', 'post')

	def pre_move(self, user):
			self.logger.info("Running a pre_move hook for %%s.", user)
			self.run(user, 'move', 'pre')

	def post_move(self, user):
			self.logger.info("Running a post_move hook for %%s.", user)
			self.run(user, 'move', 'post')

	def pre_remove(self, user):
			self.logger.info("Running a pre_remove hook for %%s.", user)
			self.run(user, 'remove', 'pre')

	def post_remove(self, user):
			self.logger.info("Running a post_remove hook for %%s.", user)
			self.run(user, 'remove', 'post')

	def run(self, user, action, when):
		self.logger.info("***** Running {} {} hook for user {}.".format(when, action, user))
		# udm_properties[k] is only filled from LDAP, if k was in the input
		# don't try to get_udm_object() on a user not {anymore, yet} in ldap
		if not user.udm_properties.get('organisation') and not ((action == 'create' and when == 'pre') or (action == 'remove' and when == 'post')):
			obj = user.get_udm_object(self.lo)
			user.udm_properties['organisation'] = obj.info.get('organisation', '')
		user.udm_properties['organisation'] = user.udm_properties.get('organisation', '') + ',{}-{}'.format(when, action)
		if when == 'post' and action != 'remove':
			user.modify(self.lo)
		fn_touchfile = os.path.join(%(tmpdir)r, '%%s-%%s' %% (when, action))
		open(fn_touchfile, 'w').write('EXECUTED\\n')
''' % {'tmpdir': self.tmpdir}

		fn = os.path.join(self.hook_basedir, fn)
		self.cleanup_files.add(fn)
		with open(fn, 'w') as fd:
			fd.write(data)
		self.log.info('Created hook %r', fn)

	def cleanup(self):
		shutil.rmtree(self.tmpdir, ignore_errors=True)
		for fn in self.cleanup_files:
			try:
				os.remove(fn)
			except (IOError, OSError):
				self.log.warning('Failed to remove %r' % (fn,))
			if fn.endswith('.py'):
				try:
					os.remove('%sc' % (fn,))  # also remove .pyc files
				except (IOError, OSError):
					pass


class CLI_Import_v2_Tester(object):
	ucr = univention.testing.ucr.UCSTestConfigRegistry()

	def __init__(self):
		self.tmpdir = tempfile.mkdtemp(prefix='34_import-users_via_cli_v2.', dir='/tmp/')
		self.log = logging.getLogger('main')
		self.lo = None
		self.ldap_status = None
		self.hook_fn_set = set()
		self.ou_A = Bunch()
		self.ou_B = Bunch()
		self.ou_C = Bunch()
		self.ucr.load()
		try:
			maildomain = self.ucr["mail/hosteddomains"].split()[0]
		except (AttributeError, IndexError):
			maildomain = self.ucr["domainname"]
		self.default_config = ConfigDict({
			"factory": "ucsschool.importer.default_user_import_factory.DefaultUserImportFactory",
			"classes": {},
			"input": {
				"type": "csv",
				"filename": "import.csv"
			},
			"csv": {
				"mapping": {
					"OUs": "schools",
					"Vor": "firstname",
					"Nach": "lastname",
					"Gruppen": "school_classes",
					"E-Mail": "email",
					"Beschreibung": "description",
				}
			},
			"maildomain": maildomain,
			"scheme": {
				"email": "<firstname>[0].<lastname>@<maildomain>",
				"recordUID": "<firstname>;<lastname>;<email>",
				"username": {
					"allow_rename": False,
					"default": "<:umlauts><firstname>[0].<lastname>[COUNTER2]"
				},
			},
			"sourceUID": "sourceDB",
			"user_role": "student",
			"tolerate_errors": 0,
		})

	def cleanup(self):
		self.log.info('Purging %r', self.tmpdir)
		shutil.rmtree(self.tmpdir, ignore_errors=True)
		for hook_fn in self.hook_fn_set:
			try:
				os.remove(hook_fn)
			except (IOError, OSError):
				self.log.warning('Failed to remove %r' % (hook_fn,))

	def create_config_json(self, values=None, config=None):
		"""
		Creates a config file for "ucs-school-user-import".
		Default values may be overridden via a dict called values.
		>>> values = {'user_role': 'teacher',
					  'input:type': 'csv' }
		>>> create_config_json(values=values)
		'/tmp/config.dkgfcsdz'
		>>> create_config_json(values=values, config=DEFAULT_CONFIG)
		'/tmp/config.dkgfcsdz'
		"""
		fn = tempfile.mkstemp(prefix='config.', dir=self.tmpdir)[1]
		if not config:
			config = copy.deepcopy(self.default_config)
		if values:
			for config_option, value in values.iteritems():
				config.update_entry(config_option, value)
		with open(fn, 'w') as fd:
			json.dump(config, fd)

		return fn

	def create_csv_file(self, person_list, mapping=None, fn_csv=None):
		"""
		Create CSV file for given persons
		>>> create_csv_file([Person('schoolA', 'student'), Person('schoolB', 'teacher')])
		'/tmp/import.sldfhgsg.csv'
		>>> create_csv_file([Person('schoolA', 'student'), Person('schoolB', 'teacher')], fn_csv='/tmp/import.foo.csv')
		'/tmp/import.foo.csv'
		>>> create_csv_file([Person('schoolA', 'student'), Person('schoolB', 'teacher')], headers={'firstname': 'Vorname', ...})
		'/tmp/import.cetjdfgj.csv'
		"""
		if mapping:
			header2properties = mapping
		else:
			header2properties = self.default_config['csv']['mapping']

		properties2headers = {v: k for k, v in header2properties.iteritems()}

		header_row = header2properties.keys()
		random.shuffle(header_row)
		self.log.debug('Header row = %r', header_row)

		fn = fn_csv if fn_csv else tempfile.mkstemp(prefix='users.', dir=self.tmpdir)[1]
		writer = csv.DictWriter(
			open(fn, 'w'),
			header_row,
			restval='',
			delimiter=',',
			quotechar='"',
			quoting=csv.QUOTE_ALL)
		writer.writeheader()
		for person in person_list:
			person_dict = person.map_to_dict(properties2headers)
			self.log.debug('Person data = %r', person_dict)
			writer.writerow(person_dict)
		return fn

	def save_ldap_status(self):
		self.log.debug('Saving LDAP status...')
		self.ldap_status = set(self.lo.searchDn())
		self.log.debug('LDAP status saved.')

	def diff_ldap_status(self):
		self.log.debug('Reading LDAP status for check differences...')
		new_ldap_status = set(self.lo.searchDn())
		new_objects = new_ldap_status - self.ldap_status
		removed_objects = self.ldap_status - new_ldap_status
		self.log.debug('LDAP status diffed.')
		self.log.debug('New objects: %r', new_objects)
		self.log.debug('Removed objects: %r', removed_objects)
		return Bunch(new=new_objects, removed=removed_objects)

	@classmethod
	def syntax_date2_dateformat(cls, userexpirydate):
		# copied from 61_udm-users/26_password_expire_date
		## Note: this is a timezone dependend value
		_re_iso = re.compile('^[0-9]{4}-[0-9]{2}-[0-9]{2}$')
		_re_de = re.compile('^[0-9]{1,2}\.[0-9]{1,2}\.[0-9]+$')
		if _re_iso.match(userexpirydate):
			return "%Y-%m-%d"
		elif _re_de.match(userexpirydate):
			return "%d.%m.%y"
		else:
			raise ValueError

	@classmethod
	def udm_formula_for_shadowExpire(cls, userexpirydate):
		# copied from 61_udm-users/26_password_expire_date
		## Note: this is a timezone dependend value
		dateformat = cls.syntax_date2_dateformat(userexpirydate)
		return str(long(time.mktime(time.strptime(userexpirydate, dateformat)) / 3600 / 24 + 1))

	def run_import(self, args, fail_on_error=True):
		cmd = ['/usr/share/ucs-school-import/scripts/ucs-school-user-import'] + args
		self.log.info('Starting import: %r', cmd)
		sys.stdout.flush()
		sys.stderr.flush()
		exitcode = subprocess.call(cmd)
		self.log.info('Import process exited with exit code %r', exitcode)
		if fail_on_error and exitcode:
			self.log.error('As requested raising an exception due to non-zero exit code')
			raise ImportException('Non-zero exit code %r' % (exitcode,))
		return exitcode

	def check_new_and_removed_users(self, exp_new, exp_removed):
		new_users = [x for x in self.diff_ldap_status().new if x.startswith('uid=')]
		if len(new_users) != exp_new:
			self.log.error('Invalid number of new users (expected %d, found %d)! Found new objects: %r',
				exp_new, len(new_users), new_users)
			utils.fail('Stopping because of invalid number of new users.')
		removed_users = [x for x in self.diff_ldap_status().removed if x.startswith('uid=')]
		if len(removed_users) != exp_removed:
			self.log.error('Invalid number of removed users (expected %d, found %d)! Removed objects: %r',
				exp_removed, len(removed_users), removed_users)
			utils.fail('Stopping because of invalid number of removed users.')

	def test_create_modify_delete_user(self):
		"""
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			import user with role <role>
			modify user with role <role> → changing group memberships
			remove user with role <role>
		"""
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			self.log.info('*** Importing a new single user with role %r', role)

			person = Person(self.ou_A.name, role)
			fn_csv = self.create_csv_file(person_list=[person])
			source_uid = 'sourceUID-%s' % (uts.random_string(),)
			record_uid = '%s;%s;%s' % (person.firstname, person.lastname, person.mail)
			config = {
				'sourceUID': source_uid,
				'input:filename': fn_csv,
				'user_role': role,
			}
			fn_config = self.create_config_json(values=config)
			# save ldap state for later comparison
			self.save_ldap_status()

			# start import
			self.run_import(['-c', fn_config])

			# check for new users in LDAP
			self.check_new_and_removed_users(1, 0)

			# update dn+username of person and verify LDAP attributes
			new_users = [x for x in self.diff_ldap_status().new if x.startswith('uid=')]
			person.update(dn=new_users[0], record_uid=record_uid, source_uid=source_uid)
			person.verify()

			self.log.info('*** Modifying a single user with role %r', role)

			if role == 'student':
				person.school_classes = {}
			if role in ('student', 'teacher', 'teacher_and_staff'):
				person.append_random_class()

			self.create_csv_file(person_list=[person], fn_csv=fn_csv)
			fn_config = self.create_config_json(values=config)
			# save ldap state for later comparison
			self.save_ldap_status()

			# start import
			self.run_import(['-c', fn_config])

			# check for new users in LDAP
			self.check_new_and_removed_users(0, 0)

			# verify LDAP attributes
			person.verify()

			self.log.info('*** Remove a single user with role %r', role)

			# mark person as removed
			person.set_mode_to_delete()
			self.create_csv_file(person_list=[], fn_csv=fn_csv)
			fn_config = self.create_config_json(values=config)
			# save ldap state for later comparison
			self.save_ldap_status()

			# start import
			self.run_import(['-c', fn_config])

			# check for new users in LDAP
			self.check_new_and_removed_users(0, 1)

			# verify LDAP attributes
			person.verify()

		self.log.info('Creating, modifying, removing user with role %r was successful', role)
		self.log.info('Test was successful.\n\n\n')

	def test_create_modify_delete_user_with_username_and_recordUID_and_UDM_property(self):
		"""
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			import user with role <role> and given username
			remove user with role <role> and given username
		"""
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			hooks = PyHooks()
			hooks.create_hooks()
			try:
				self.log.info('*** Importing a new single user with role %r and username and recordUID', role)

				source_uid = 'sourceUID-%s' % (uts.random_string(),)
				record_uid_A = uts.random_name()
				record_uid_B = uts.random_name()

				config = copy.deepcopy(self.default_config)
				config.update_entry('sourceUID', source_uid)
				config.update_entry('csv:mapping:Benutzername', 'username')
				config.update_entry('csv:mapping:DBID', 'record_uid')
				config.update_entry('user_role', role)

				person_list = [Person(self.ou_A.name, role), Person(self.ou_A.name, role)]
				person_list[0].update(record_uid=record_uid_A, source_uid=source_uid, description=uts.random_name())
				person_list[1].update(record_uid=record_uid_B, source_uid=source_uid, description=uts.random_name())
				fn_csv = self.create_csv_file(person_list=person_list, mapping=config['csv']['mapping'])
				config.update_entry('input:filename', fn_csv)
				fn_config = self.create_config_json(config=config)
				# save ldap state for later comparison
				self.save_ldap_status()

				# start import
				self.run_import(['-c', fn_config, '-i', fn_csv])

				# check for new users in LDAP
				self.check_new_and_removed_users(2, 0)

				# update dn+username of person and verify LDAP attributes
				for person in person_list:
					person.verify()
				utils.verify_ldap_object(person.dn, expected_attr={'o': [',pre-create,post-create']}, strict=True, should_exist=True)

				def assert_and_print(exists, fn):
					status = os.path.exists(os.path.join(hooks.tmpdir, fn))
					self.log.debug('Hook touch file %r exists = %r' % (fn, status))
					assert exists == status, 'Unexpected status of hook touch file: exists=%s  expected=%s' % (status, exists)

				for fn in ('pre-create', 'post-create'):
					assert_and_print(True, fn)
				for fn in ('pre-modify', 'post-modify', 'pre-remove', 'post-remove'):
					assert_and_print(False, fn)

				self.log.info('*** Modifying a single user with role %r and username and recordUID', role)

				person_list[0].firstname = uts.random_name()
				person_list[1].lastname = uts.random_name()
				self.create_csv_file(person_list=person_list, mapping=config['csv']['mapping'], fn_csv=fn_csv)
				fn_config = self.create_config_json(values=config)
				# save ldap state for later comparison
				self.save_ldap_status()
				# start import
				self.run_import(['-c', fn_config, '-i', fn_csv])
				# check for new users in LDAP
				self.check_new_and_removed_users(0, 0)

				# verify LDAP attributes
				for person in person_list:
					person.verify()
				utils.verify_ldap_object(person.dn, expected_attr={'o': [',pre-create,post-create,pre-modify,post-modify']}, strict=True, should_exist=True)
				for fn in ('pre-create', 'post-create', 'pre-modify', 'post-modify'):
					assert_and_print(True, fn)
				for fn in ('pre-remove', 'post-remove'):
					assert_and_print(False, fn)

				self.log.info('*** Remove a single user with role %r and username and recordUID', role)

				# mark first person as removed
				person_list[0].set_mode_to_delete()
				self.create_csv_file(person_list=[person_list[1]], mapping=config['csv']['mapping'], fn_csv=fn_csv)
				fn_config = self.create_config_json(values=config)
				# save ldap state for later comparison
				self.save_ldap_status()

				# start import
				self.run_import(['-c', fn_config, '-i', fn_csv])

				# check for new users in LDAP
				self.check_new_and_removed_users(0, 1)

				# verify LDAP attributes
				for person in person_list:
					person.verify()
				for fn in ('pre-create', 'post-create', 'pre-modify', 'post-modify', 'pre-remove', 'post-remove'):
					assert_and_print(True, fn)

			finally:
				hooks.cleanup()
			self.log.info('Creating, modifying, removing user with role %r and username/recordUID was successful', role)
		self.log.info('Test was successful.\n\n\n')

	def test_create_with_username_scheme(self):
		"""
		Test creation of usernames from a special username scheme (Bug #41243, #41244).
		"""
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			for scheme in ["ALWAYSCOUNTER", "COUNTER2"]:
				self.log.info('*** Importing a new single user with role %r, username scheme %r and recordUID 1. time', role, scheme)

				source_uid = 'sourceUID-%s' % (uts.random_string(),)
				record_uid = uts.random_name()

				config = copy.deepcopy(self.default_config)
				config.update_entry('sourceUID', source_uid)
				config.update_entry('csv:mapping:DBID', 'record_uid')
				config.update_entry('scheme:recordUID', '<record_uid>')
				config.update_entry('user_role', role)
				config.update_entry('scheme:username:default', "<:umlauts>user-<firstname>[0:2].<lastname>[0:2]-[{}]".format(scheme))

				person = Person(self.ou_A.name, role)
				person.update(record_uid=record_uid, source_uid=source_uid, username=None)
				fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
				config.update_entry('input:filename', fn_csv)
				fn_config = self.create_config_json(config=config)
				# save ldap state for later comparison
				self.save_ldap_status()

				# start import
				self.run_import(['-c', fn_config, '-i', fn_csv])

				# check for new users in LDAP
				self.check_new_and_removed_users(1, 0)

				# update dn+username of person and verify LDAP attributes
				new_users = [x for x in self.diff_ldap_status().new if x.startswith('uid=')]
				person.update(dn=new_users[0], record_uid=record_uid, source_uid=source_uid)
				person.verify()

				username_prefix = 'user%s.%s' % (person.firstname[0:2], person.lastname[0:2])
				self.log.info("Calculated username_prefix is %r.", username_prefix)
				if person.username != "{}{}".format(username_prefix, "1" if scheme == "ALWAYSCOUNTER" else ""):
					utils.fail('username %r is not expected string "%s%s"' % (person.username, username_prefix, "1" if scheme == "ALWAYSCOUNTER" else ""))
				self.log.info('Username %r is expected with string "%s%s"', person.username, username_prefix, "1" if scheme == "ALWAYSCOUNTER" else "")

				# check if username history object exists
				self.log.info('Checking for unique-usernames object...')
				dn = 'cn=%s,cn=unique-usernames,cn=ucsschool,cn=univention,%s' % (username_prefix, self.lo.base)
				attrs = {
					'objectClass': ['ucsschoolUsername'],
					'ucsschoolUsernameNextNumber': ['2'],
					'cn': [username_prefix],
				}
				utils.verify_ldap_object(dn, expected_attr=attrs, strict=True, should_exist=True)
				self.log.debug('unique-usernames object %r:\n%s', dn, pprint.PrettyPrinter(indent=2).pformat(self.lo.get(dn)))
				self.log.info('unique-usernames object has been found and is correct.')

				for ext in [2, 3]:
					self.log.info('*** Deleting user with role %r and username and recordUID %d. time', role, ext - 1)
					fn_csv = self.create_csv_file(person_list=[], mapping=config['csv']['mapping'])
					config.update_entry('input:filename', fn_csv)
					fn_config = self.create_config_json(config=config)
					self.save_ldap_status()
					self.run_import(['-c', fn_config, '-i', fn_csv])
					self.check_new_and_removed_users(0, 1)

					self.log.info('*** Importing same user with role %r with same username and recordUID %d. time', role, ext)
					person.update(record_uid=record_uid, source_uid=source_uid, username=None)
					fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
					config.update_entry('input:filename', fn_csv)
					fn_config = self.create_config_json(config=config)
					self.save_ldap_status()
					self.run_import(['-c', fn_config, '-i', fn_csv])
					self.check_new_and_removed_users(1, 0)

					new_users = [x for x in self.diff_ldap_status().new if x.startswith('uid=')]
					person.update(dn=new_users[0], record_uid=record_uid, source_uid=source_uid)
					person.verify()
					if person.username != "{}{}".format(username_prefix, ext):
						utils.fail('username %r is not expected string "%s%d"' % (person.username, username_prefix, ext))
					self.log.info('Username %r is expected with string "%s%d', person.username, username_prefix, ext)

					self.log.info('Checking for unique-usernames object...')
					dn = 'cn=%s,cn=unique-usernames,cn=ucsschool,cn=univention,%s' % (username_prefix, self.lo.base)
					attrs = {
						'objectClass': ['ucsschoolUsername'],
						'ucsschoolUsernameNextNumber': [str(ext + 1)],
						'cn': [username_prefix],
					}
					self.log.info('unique-usernames object is correct.')

				self.log.info('Test was successful.\n\n\n')

	def test_create_modify_only(self):
		"""
		Bug #41775, #41350: check if the --no-delete option works as expected
		"""
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			self.log.info('*** Add/modify without delete with role %r', role)

			source_uid = 'sourceUID-%s' % (uts.random_string(),)
			config = copy.deepcopy(self.default_config)
			config.update_entry('csv:mapping:Benutzername', 'username')
			config.update_entry('scheme:recordUID', '<username>')
			config.update_entry('sourceUID', source_uid)
			config.update_entry('user_role', role)
			personA = Person(self.ou_A.name, role)
			personB = Person(self.ou_A.name, role)

			self.log.info('Adding user A %r with role %r', personA.username, role)
			fn_csv = self.create_csv_file(person_list=[personA], mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(values=config)
			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv, '--no-delete'])

			userlist = self.lo.searchDn('uid=%s' % (personA.username,))
			if len(userlist) != 1:
				self.log.error('Invalid number of users for personA! Found new objects: %r', userlist)
				utils.fail('Stopping here')
			personA.verify()

			self.log.info('Adding user B %r with role %r', personB.username, role)
			fn_csv = self.create_csv_file(person_list=[personB], mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(values=config)
			self.run_import(['-c', fn_config, '-i', fn_csv, '--no-delete'])

			for username in (personA.username, personB.username):
				userlist = self.lo.searchDn('uid=%s' % (username,))
				if len(userlist) != 1:
					self.log.error('Invalid number of user objects for user %r! Found new objects: %r', username, userlist)
					utils.fail('Stopping here')
			personA.verify()
			personB.verify()

			self.log.info('Modifying user A %r with role %r', personA.username, role)
			personA.lastname = uts.random_name()
			config.update_entry('no_delete', 'True')
			fn_csv = self.create_csv_file(person_list=[personA], mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(values=config)
			self.run_import(['-c', fn_config, '-i', fn_csv])  # '--no-delete'  is not specified on purpose -> using config option "no_delete"

			for username in (personA.username, personB.username):
				userlist = self.lo.searchDn('uid=%s' % (username,))
				if len(userlist) != 1:
					self.log.error('Invalid number of user objects for user %r! Found new objects: %r', username, userlist)
					utils.fail('Stopping here')
			personA.verify()
			personB.verify()
		self.log.info('Test was successful.\n\n\n')

	def test_create_with_attribute_schemes(self):
		"""
		Tests Bug #41472.
		Create a new user for each role:
		- use UDM template syntax (http://docs.software-univention.de/handbuch-4.1.html#users:templates)
          to define several custom values
        - employeeNumber is filled with a string consisting of first and last name and description
        - mailPrimaryAddress is also built from those attributes
		"""
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			self.log.info('*** Importing a new single user with role %r from templates', role)

			source_uid = 'sourceUID-%s' % (uts.random_string(),)
			record_uid = uts.random_name()

			config = copy.deepcopy(self.default_config)
			config.update_entry('sourceUID', source_uid)
			config.update_entry('csv:mapping:employeeNumber', 'employeeNumber')
			config.update_entry('csv:mapping:DBID', 'record_uid')
			config.update_entry('scheme:recordUID', '<record_uid>')
			config.update_entry('user_role', role)
			config.update_entry('scheme:username:default', "<:umlauts>user-<firstname>[0:2].<lastname>[0:2]-[ALWAYSCOUNTER]")
			config.update_entry('scheme:email', "<:umlauts><firstname:lower>[0:3].<lastname:lower>[2:5]@example.com")
			config.update_entry('scheme:employeeNumber', "The user's name is <firstname:upper> <lastname> <description>")

			person = Person(self.ou_A.name, role)
			person.update(record_uid=record_uid, source_uid=source_uid, username=None, mail=None, description=uts.random_name())
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(config=config)
			# save ldap state for later comparison
			self.save_ldap_status()

			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv])

			# check for new users in LDAP
			new_users = [x for x in self.diff_ldap_status().new if x.startswith('uid=')]
			if len(new_users) != 1:
				self.log.error('Invalid number of new users! Found new objects: %r', new_users)
				utils.fail('Stopping here')

			# update dn+username of person and verify LDAP attributes
			mail = '%s.%s@example.com' % (person.firstname[0:3].lower(), person.lastname[2:5].lower())
			person.update(dn=new_users[0], record_uid=record_uid, source_uid=source_uid, mail=mail)
			person.verify()

			username_prefix = 'user%s.%s' % (person.firstname[0:2], person.lastname[0:2])
			if person.username != "{}1".format(username_prefix):
				utils.fail('username %r is not expected string %r' % (person.username, "{}1".format(username_prefix)))
			self.log.info('Username %r is not expected string %r', person.username, "{}1".format(username_prefix))

			self.log.info('Testing mailPrimaryAddress and description...')
			values = {
				'employeeNumber': ["The user's name is %s %s %s" % (person.firstname.upper(), person.lastname, person.description)],
			}
			utils.verify_ldap_object(person.dn, expected_attr=values, strict=True, should_exist=True)
			self.log.debug('User object %r:\n%s', person.dn, pprint.PrettyPrinter(indent=2).pformat(self.lo.get(person.dn)))
		self.log.info('Test was successful.\n\n\n')

	def test_multivalue_attributes(self):
		"""
		Test creation of multi-value fields (Bug #41471).
        - mailAlternativeAddress is filled with multiple strings
		"""
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			self.log.info('*** Importing a new single user with role %r with multivalue attributes', role)

			source_uid = 'sourceUID-%s' % (uts.random_string(),)

			config = copy.deepcopy(self.default_config)
			config.update_entry('sourceUID', source_uid)
			config.update_entry('csv:incell-delimiter:default', ';')
			config.update_entry('csv:mapping:Benutzername', 'username')
			config.update_entry('csv:mapping:recordUID', 'record_uid')
			config.update_entry('csv:mapping:mailAlternativeAddress', 'mailAlternativeAddress')
			config.update_entry('scheme:recordUID', '<username>')
			config.update_entry('sourceUID', source_uid)
			config.update_entry('user_role', role)

			class MultiPerson(Person):
				def __init__(self, school, role):
					Person.__init__(self, school, role)
					self.mailAlternativeAddress = '%s@example.com;%s@example.com;%s@example.com' % (uts.random_name(), uts.random_name(), uts.random_name())

				def map_to_dict(self, value_map):
					result = Person.map_to_dict(self, value_map)
					result[value_map.get('mailAlternativeAddress', '__EMPTY__')] = self.mailAlternativeAddress
					return result

				def expected_attributes(self):
					result = Person.expected_attributes(self)
					result['mailAlternativeAddress'] = self.mailAlternativeAddress.split(',')

			# create person with 3 alternative mail addresses
			person = MultiPerson(self.ou_A.name, role)
			person.update(record_uid=person.username, source_uid=source_uid)
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(config=config)
			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv])

			self.log.debug('User object %r:\n%s', person.dn, pprint.PrettyPrinter(indent=2).pformat(self.lo.get(person.dn)))
			person.verify()

			# modify person and set 1 alternative mail address
			person.update(mailAlternativeAddress='%s@example.com' % (uts.random_name(),))
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(config=config)
			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv])

			self.log.debug('User object %r:\n%s', person.dn, pprint.PrettyPrinter(indent=2).pformat(self.lo.get(person.dn)))
			person.verify()
		self.log.info('Test was successful.\n\n\n')

	def test_school_change(self):
		"""
		Test moving a user from ou_A to ou_B (Bug #41609).
		"""
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			self.log.info('*** Importing a new single user with role %r and change school afterwards', role)

			source_uid = 'sourceUID-%s' % (uts.random_string(),)

			config = copy.deepcopy(self.default_config)
			config.update_entry('sourceUID', source_uid)
			config.update_entry('csv:mapping:Benutzername', 'username')
			config.update_entry('csv:mapping:recordUID', 'record_uid')
			config.update_entry('scheme:recordUID', '<username>')
			config.update_entry('sourceUID', source_uid)
			config.update_entry('user_role', role)

			# create person in school A
			person = Person(self.ou_A.name, role)
			person.update(record_uid=person.username, source_uid=source_uid, school_classes={})
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(config=config)
			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv])

			self.log.debug('User object %r:\n%s', person.dn, pprint.PrettyPrinter(indent=2).pformat(self.lo.get(person.dn)))
			person.verify()

			# move person to school B
			person.update(school=self.ou_B.name, schools=[self.ou_B.name])
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(config=config)
			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv])

			userlist = self.lo.searchDn('uid=%s' % (person.username,))
			if len(userlist) != 1:
				self.log.error('Invalid number of user objects for user %r! Found new objects: %r', person.username, userlist)
				utils.fail('Stopping here')

			person.update(dn=userlist[0])
			self.log.debug('User object %r:\n%s', person.dn, pprint.PrettyPrinter(indent=2).pformat(self.lo.get(person.dn)))
			person.verify()

		self.log.info('Test was successful.\n\n\n')

	def test_lowercase_username_with_counter(self):
		"""
		Bug #41645: a username scheme with <:lower> and [COUNTER2]
		"""
		for scheme in ["ALWAYSCOUNTER", "COUNTER2"]:
			for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
				self.log.info('*** Importing a new single user with role %r from templates with scheme %r', role, scheme)

				source_uid = 'sourceUID-%s' % (uts.random_string(),)
				record_uid = uts.random_name()

				config = copy.deepcopy(self.default_config)
				config.update_entry('sourceUID', source_uid)
				config.update_entry('csv:mapping:employeeNumber', 'employeeNumber')
				config.update_entry('csv:mapping:DBID', 'record_uid')
				config.update_entry('scheme:recordUID', '<record_uid>')
				config.update_entry('user_role', role)
				config.update_entry('scheme:username:default', "<:lower><:umlauts><firstname>[0:6].<lastname>[0:3]a[{}]".format(scheme))
				config.update_entry('scheme:email', "<:umlauts><firstname:lower>.<lastname:lower>@example.com")
				config.update_entry('scheme:employeeNumber', "The user's name is <firstname:upper> <lastname> <description>")

				person = Person(self.ou_A.name, role)
				person.update(record_uid=record_uid, source_uid=source_uid, username=None, mail=None, description=uts.random_name())
				fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
				fn_config = self.create_config_json(config=config)
				# save ldap state for later comparison
				self.save_ldap_status()

				# start import
				self.run_import(['-c', fn_config, '-i', fn_csv])

				# check for new users in LDAP
				new_users = [x for x in self.diff_ldap_status().new if x.startswith('uid=')]
				if len(new_users) != 1:
					self.log.error('Invalid number of new users! Found new objects: %r', new_users)
					utils.fail('Stopping here')

				# update dn+username of person and verify LDAP attributes
				mail = '%s.%s@example.com' % (person.firstname.lower(), person.lastname.lower())
				person.update(dn=new_users[0], record_uid=record_uid, source_uid=source_uid, mail=mail)
				person.verify()

				username_prefix = '%s.%sa' % (person.firstname[0:6], person.lastname[0:3])
				if person.username != "{}{}".format(username_prefix, "1" if scheme == "ALWAYSCOUNTER" else ""):
					utils.fail('username %r is not expected string %r.' % (person.username, "{}{}".format(username_prefix, "1" if scheme == "ALWAYSCOUNTER" else "")))
				self.log.info('Username %r is not expected with string %r.', person.username, "{}{}".format(username_prefix, "1" if scheme == "ALWAYSCOUNTER" else ""))

				self.log.info('Testing mailPrimaryAddress and description...')
				values = {
					'employeeNumber': ["The user's name is %s %s %s" % (person.firstname.upper(), person.lastname, person.description)],
				}
				utils.verify_ldap_object(person.dn, expected_attr=values, strict=True, should_exist=True)
				self.log.debug('User object %r:\n%s', person.dn, pprint.PrettyPrinter(indent=2).pformat(self.lo.get(person.dn)))
		self.log.info('Test was successful.\n\n\n')

	def test_iso_birthday(self):
		"""
		Bug #41642: Create/modify a new user for each role:
        - set ISO birthday (2016-06-23) for each user type
		"""
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			self.log.info('*** Importing a new single user with role %r with multivalue attributes', role)

			source_uid = 'sourceUID-%s' % (uts.random_string(),)

			config = copy.deepcopy(self.default_config)
			config.update_entry('sourceUID', source_uid)
			config.update_entry('csv:incell-delimiter:default', ';')
			config.update_entry('csv:mapping:Benutzername', 'username')
			config.update_entry('csv:mapping:recordUID', 'record_uid')
			config.update_entry('csv:mapping:birthday', 'birthday')
			config.update_entry('scheme:recordUID', '<username>')
			config.update_entry('sourceUID', source_uid)
			config.update_entry('user_role', role)

			class BirthdayPerson(Person):
				def __init__(self, school, role):
					Person.__init__(self, school, role)
					self.birthday = time.strftime('%Y-%m-%d')

				def map_to_dict(self, value_map):
					result = Person.map_to_dict(self, value_map)
					result[value_map.get('birthday', '__EMPTY__')] = self.birthday
					return result

				def expected_attributes(self):
					result = Person.expected_attributes(self)
					result['birthday'] = [self.birthday]

			# create person with ISO birthday (today)
			person = BirthdayPerson(self.ou_A.name, role)
			person.update(record_uid=person.username, source_uid=source_uid)
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(config=config)
			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv])

			self.log.debug('User object %r:\n%s', person.dn, pprint.PrettyPrinter(indent=2).pformat(self.lo.get(person.dn)))
			person.verify()

			# modify person and set birthday to new year's day
			person.update(birthday='2016-01-01')
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(config=config)
			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv])

			self.log.debug('User object %r:\n%s', person.dn, pprint.PrettyPrinter(indent=2).pformat(self.lo.get(person.dn)))
			person.verify()
		self.log.info('Test was successful.\n\n\n')

	def test_create_modify_with_extended_attribute(self, udm):
		"""
		Bug #41707: set values in extended attribute
		"""

		ext_attr_name = uts.random_name()
		properties = {
			'position': udm.UNIVENTION_CONTAINER,
			'name': uts.random_name(),
			'shortDescription': uts.random_string(),
			'CLIName': ext_attr_name,
			'module': 'users/user',
			'objectClass': 'univentionFreeAttributes',
			'ldapMapping': 'univentionFreeAttribute15'
		}
		udm.create_object('settings/extended_attribute', **properties)

		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			self.log.info('*** Importing a new single user with role %r with ', role)

			source_uid = 'sourceUID-%s' % (uts.random_string(),)

			config = copy.deepcopy(self.default_config)
			config.update_entry('sourceUID', source_uid)
			config.update_entry('csv:mapping:extattr', ext_attr_name)
			config.update_entry('csv:mapping:Benutzername', 'username')
			config.update_entry('csv:mapping:recordUID', 'record_uid')
			config.update_entry('scheme:recordUID', '<username>')
			config.update_entry('scheme:%s' % (ext_attr_name,), "<firstname:upper> <lastname> <description>")
			config.update_entry('sourceUID', source_uid)
			config.update_entry('user_role', role)

			class ExtAttrPerson(Person):
				def __init__(self, school, role):
					Person.__init__(self, school, role)
					self.extattr = time.strftime('%Y-%m-%d')

				def map_to_dict(self, value_map):
					result = Person.map_to_dict(self, value_map)
					result[value_map.get(ext_attr_name, '__EMPTY__')] = self.extattr
					return result

				def expected_attributes(self):
					result = Person.expected_attributes(self)
					result['univentionFreeAttributes15'] = [self.extattr]

			# create person with extended attribute (today)
			person = ExtAttrPerson(self.ou_A.name, role)
			person.update(record_uid=person.username, source_uid=source_uid)
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(config=config)
			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv])

			self.log.debug('User object %r:\n%s', person.dn, pprint.PrettyPrinter(indent=2).pformat(self.lo.get(person.dn)))
			person.verify()

			# modify person and set ext_attr to random value
			person.update(extattr=uts.random_string())
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(config=config)
			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv])

			self.log.debug('User object %r:\n%s', person.dn, pprint.PrettyPrinter(indent=2).pformat(self.lo.get(person.dn)))
			person.verify()
		self.log.info('Test was successful.\n\n\n')

	def test_create_with_empty_class_name(self):
		"""
		Bug #41847: import users with an empty class name
		"""
		first_user = True
		config = copy.deepcopy(self.default_config)
		source_uid = 'sourceUID-%s' % (uts.random_string(),)
		config.update_entry('sourceUID', source_uid)

		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			self.log.info('*** Importing a new single user with role %r and empty class name.', role)

			config.update_entry('user_role', role)

			person = Person(self.ou_A.name, role)
			person.update(school_classes={})
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			config.update_entry('input:filename', fn_csv)
			fn_config = self.create_config_json(config=config)
			# save ldap state for later comparison
			self.save_ldap_status()

			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv])

			# check for new users in LDAP
			if first_user:
				users_removed = 0
				first_user = False
			else:
				users_removed = 1
			self.check_new_and_removed_users(1, users_removed)

			self.log.info('Test was successful.\n\n\n')

	def test_no_delete_option(self):
		"""
		Bug #41775, #41350: test --no-delete option:
		- with[out] --no-delete
		- with[out] explicit mode=D  -> should delete even when --no-delete is on
		"""
		config = copy.deepcopy(self.default_config)
		source_uid = 'sourceUID-%s' % (uts.random_string(),)
		config.update_entry('sourceUID', source_uid)

		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			self.log.info('*** Testing "--no-delete" option for role %r.', role)

			config.update_entry('user_role', role)

			person = Person(self.ou_A.name, role)
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			config.update_entry('input:filename', fn_csv)
			fn_config = self.create_config_json(config=config)
			# save ldap state for later comparison
			self.save_ldap_status()

			# start import
			self.log.info('*** Importing a user')
			self.run_import(['-c', fn_config, '-i', fn_csv])

			# check for new users in LDAP
			self.check_new_and_removed_users(1, 0)

			self.log.info('*** Importing a user, NOT deleting previous user (running with "--no-delete")')
			person = Person(self.ou_A.name, role)
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			self.save_ldap_status()
			self.run_import(['-c', fn_config, '-i', fn_csv, '--no-delete'])

			# check for new users in LDAP
			self.check_new_and_removed_users(1, 0)

			self.log.info('*** Importing a user, deleting previous two users (running without "--no-delete")')
			person = Person(self.ou_A.name, role)
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			self.save_ldap_status()
			self.run_import(['-c', fn_config, '-i', fn_csv])

			# check for new users in LDAP
			self.check_new_and_removed_users(1, 2)

			self.log.info('*** Importing a user, deleting previous user')
			person = Person(self.ou_A.name, role)
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			self.save_ldap_status()
			self.run_import(['-c', fn_config, '-i', fn_csv])

			# check for new users in LDAP
			self.check_new_and_removed_users(1, 1)

			self.log.info('*** Importing same user and running with "--no-delete"')
			person.set_mode_to_delete()
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			self.save_ldap_status()
			self.run_import(['-c', fn_config, '-i', fn_csv, '--no-delete'])

			# check for new users in LDAP
			self.check_new_and_removed_users(0, 0)

			self.log.info('*** Importing same user with action="D" and running with "--no-delete"')
			person.set_mode_to_delete()
			config_d = copy.deepcopy(config)
			config_d.update_entry('csv:mapping:Aktion', '__action')
			fn_config_d = self.create_config_json(config=config_d)
			fn_csv = self.create_csv_file(person_list=[person], mapping=config_d['csv']['mapping'])
			self.save_ldap_status()
			self.run_import(['-c', fn_config_d, '-i', fn_csv, '--no-delete'])

			# check for new users in LDAP
			self.check_new_and_removed_users(0, 1)

			self.log.info('Test was successful.\n\n\n')

	def test_modify_with_several_groups(self, udm):
		"""
		Bug #41907:
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			- create user with 2 schools and 2 classes
			- add user to several groups for each school:
			  - global group
			  - workgroup
			  - class
			  - extra group 1 (random name <RANDOM>)
			  - extra group 2 (same naming schema as workgroup/class <OU>-<NAME>)
			- modify user with role <role>
			  - add user to new random class
			  - remove user from class_B
			- remove user with role <role>
		"""
		self.log.debug('*** Creating groups...')
		global_group_dn, global_group_name = udm.create_group()
		workgroup_A_dn, workgroup_A_name = udm.create_group(
			position='cn=schueler,cn=groups,%s' % (self.ou_A.dn,),
			name="{}-{}".format(self.ou_A.name, uts.random_groupname()))
		class_A_dn, class_A_name = udm.create_group(
			position='cn=klassen,cn=schueler,cn=groups,%s' % (self.ou_A.dn,),
			name="{}-{}".format(self.ou_A.name, uts.random_groupname()))
		cn_A_dn = udm.create_object('container/cn', position=self.ou_A.dn, name='kurs-%s' % uts.random_string())
		extra_A_group1_dn, extra_A_group1_name = udm.create_group(position=cn_A_dn)
		extra_A_group2_dn, extra_A_group2_name = udm.create_group(
			position=cn_A_dn,
			name="{}-{}".format(self.ou_A.name, uts.random_groupname()))

		workgroup_B_dn, workgroup_B_name = udm.create_group(
			position='cn=schueler,cn=groups,%s' % (self.ou_B.dn,),
			name="{}-{}".format(self.ou_B.name, uts.random_groupname()))
		class_B_dn, class_B_name = udm.create_group(
			position='cn=klassen,cn=schueler,cn=groups,%s' % (self.ou_B.dn,),
			name="{}-{}".format(self.ou_B.name, uts.random_groupname()))
		cn_B_dn = udm.create_object('container/cn', position=self.ou_B.dn, name='kurs-%s' % uts.random_string())
		extra_B_group1_dn, extra_B_group1_name = udm.create_group(position=cn_B_dn)
		extra_B_group2_dn, extra_B_group2_name = udm.create_group(
			position=cn_B_dn,
			name="{}-{}".format(self.ou_B.name, uts.random_groupname()))

		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			self.log.info('*** Importing a new single user with role %r', role)

			# create user that is member in multiple schools
			# sorted() because csv-mapping has no prim.OU -> import will use first OU, alpha.sorted
			person = Person(sorted([self.ou_A.name, self.ou_B.name])[0], role)
			person.update(schools=[self.ou_A.name, self.ou_B.name])
			if role in ('student', 'teacher', 'teacher_and_staff'):
				person.school_classes.setdefault(self.ou_A.name, []).append(class_A_name)
				person.school_classes.setdefault(self.ou_B.name, []).append(class_B_name)

			fn_csv = self.create_csv_file(person_list=[person])
			source_uid = 'sourceUID-%s' % (uts.random_string(),)
			record_uid = '%s;%s;%s' % (person.firstname, person.lastname, person.mail)
			config = {
				'sourceUID': source_uid,
				'input:filename': fn_csv,
				'user_role': role,
			}
			fn_config = self.create_config_json(values=config)
			# save ldap state for later comparison
			self.save_ldap_status()

			# start import
			self.run_import(['-c', fn_config])

			# check for new users in LDAP
			self.check_new_and_removed_users(1, 0)

			# update dn+username of person and verify LDAP attributes
			new_users = [x for x in self.diff_ldap_status().new if x.startswith('uid=')]
			user_dn = new_users[0]
			person.update(dn=user_dn, record_uid=record_uid, source_uid=source_uid)
			person.verify()
			if role in ('student', 'teacher', 'teacher_and_staff'):
				utils.verify_ldap_object(class_A_dn, expected_attr={'uniqueMember': [user_dn]}, strict=True, should_exist=True)
				utils.verify_ldap_object(class_B_dn, expected_attr={'uniqueMember': [user_dn]}, strict=True, should_exist=True)

			self.log.info('*** Adding user with role %r to groups', role)

			# add user to working groups, extra groups in both schools and to global group
			udm.modify_object('groups/group', dn=global_group_dn, append={'users': [user_dn]})
			udm.modify_object('groups/group', dn=workgroup_A_dn, append={'users': [user_dn]})
			udm.modify_object('groups/group', dn=workgroup_B_dn, append={'users': [user_dn]})
			udm.modify_object('groups/group', dn=extra_A_group1_dn, append={'users': [user_dn]})
			udm.modify_object('groups/group', dn=extra_A_group2_dn, append={'users': [user_dn]})
			udm.modify_object('groups/group', dn=extra_B_group1_dn, append={'users': [user_dn]})
			udm.modify_object('groups/group', dn=extra_B_group2_dn, append={'users': [user_dn]})
			utils.verify_ldap_object(global_group_dn, expected_attr={'uniqueMember': [user_dn]}, strict=False, should_exist=True)
			utils.verify_ldap_object(workgroup_A_dn, expected_attr={'uniqueMember': [user_dn]}, strict=False, should_exist=True)
			utils.verify_ldap_object(extra_A_group1_dn, expected_attr={'uniqueMember': [user_dn]}, strict=False, should_exist=True)
			utils.verify_ldap_object(extra_A_group2_dn, expected_attr={'uniqueMember': [user_dn]}, strict=False, should_exist=True)
			utils.verify_ldap_object(workgroup_B_dn, expected_attr={'uniqueMember': [user_dn]}, strict=False, should_exist=True)
			utils.verify_ldap_object(extra_B_group1_dn, expected_attr={'uniqueMember': [user_dn]}, strict=False, should_exist=True)
			utils.verify_ldap_object(extra_B_group2_dn, expected_attr={'uniqueMember': [user_dn]}, strict=False, should_exist=True)

			self.log.info('*** Modifying a single user with role %r', role)

			person.school_classes = {}
			if role in ('student', 'teacher', 'teacher_and_staff'):
				person.append_random_class(schools=[person.school])  # TODO FIXME Bug #41914: line should be: person.append_random_class(schools=person.schools)
				person.school_classes.setdefault(self.ou_A.name, []).append(class_A_name)
				# user is removed from class_B!

			self.create_csv_file(person_list=[person], fn_csv=fn_csv)
			fn_config = self.create_config_json(values=config)
			# save ldap state for later comparison
			self.save_ldap_status()

			# start import
			self.run_import(['-c', fn_config])

			# check for new users in LDAP
			self.check_new_and_removed_users(0, 0)

			# verify LDAP attributes
			person.verify()
			utils.verify_ldap_object(global_group_dn, expected_attr={'uniqueMember': [user_dn]}, strict=False, should_exist=True)
			utils.verify_ldap_object(workgroup_A_dn, expected_attr={'uniqueMember': [user_dn]}, strict=False, should_exist=True)
			utils.verify_ldap_object(extra_A_group1_dn, expected_attr={'uniqueMember': [user_dn]}, strict=False, should_exist=True)
			utils.verify_ldap_object(extra_A_group2_dn, expected_attr={'uniqueMember': [user_dn]}, strict=False, should_exist=True)
			utils.verify_ldap_object(workgroup_B_dn, expected_attr={'uniqueMember': [user_dn]}, strict=False, should_exist=True)
			utils.verify_ldap_object(extra_B_group1_dn, expected_attr={'uniqueMember': [user_dn]}, strict=False, should_exist=True)
			utils.verify_ldap_object(extra_B_group2_dn, expected_attr={'uniqueMember': [user_dn]}, strict=False, should_exist=True)
			if role in ('student', 'teacher', 'teacher_and_staff'):
				utils.verify_ldap_object(class_A_dn, expected_attr={'uniqueMember': [user_dn]}, strict=False, should_exist=True)
				utils.verify_ldap_object(class_B_dn, expected_attr={'uniqueMember': []}, strict=True, should_exist=True)

			self.log.info('*** Remove a single user with role %r', role)

			# mark person as removed
			person.set_mode_to_delete()
			self.create_csv_file(person_list=[], fn_csv=fn_csv)
			fn_config = self.create_config_json(values=config)
			# save ldap state for later comparison
			self.save_ldap_status()

			# start import
			self.run_import(['-c', fn_config])

			# check for new users in LDAP
			self.check_new_and_removed_users(0, 1)

			# verify LDAP attributes
			person.verify()

		self.log.info('Creating, modifying, removing user with role %r was successful', role)
		self.log.info('Test was successful.\n\n\n')

	def test_create_no_modify_classes_with_empty_class_name(self, udm):
		"""
		Bug #42288: do not modify group memberships if no group specified
		"""
		for role in ('student', 'teacher', 'teacher_and_staff'):
			self.log.info('*** Importing a new single user with role %r and two classes.', role)
			config = copy.deepcopy(self.default_config)
			source_uid = 'sourceUID-%s' % (uts.random_string(),)
			record_uid = uts.random_name()
			config.update_entry('sourceUID', source_uid)
			config.update_entry('scheme:recordUID', '<record_uid>')
			config.update_entry('user_role', role)
			config.update_entry('csv:mapping:Benutzername', 'username')
			config.update_entry('csv:mapping:recordUID', 'record_uid')

			cls1_dn, cls1_name = udm.create_group(
				position='cn=klassen,cn=schueler,cn=groups,%s' % (self.ou_A.dn,),
				name="{}-{}".format(self.ou_A.name, uts.random_groupname()))
			cls2_dn, cls2_name = udm.create_group(
				position='cn=klassen,cn=schueler,cn=groups,%s' % (self.ou_A.dn,),
				name="{}-{}".format(self.ou_A.name, uts.random_groupname()))
			person = Person(self.ou_A.name, role)
			person.update(school_classes={self.ou_A.name: [cls1_name, cls2_name]}, record_uid=record_uid,
				source_uid=source_uid, username=uts.random_username())
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			config.update_entry('input:filename', fn_csv)
			fn_config = self.create_config_json(config=config)

			# save ldap state for later comparison
			self.save_ldap_status()
			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv])
			# check for new users in LDAP
			self.check_new_and_removed_users(1, 0)
			# check school classes
			utils.verify_ldap_object(cls1_dn, expected_attr={'uniqueMember': [person.dn]}, strict=False, should_exist=True)
			utils.verify_ldap_object(cls2_dn, expected_attr={'uniqueMember': [person.dn]}, strict=False, should_exist=True)

			self.log.info('*** Modifying user: setting CSV-input to have no classes.', role)
			person.update(school_classes={})
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			config.update_entry('input:filename', fn_csv)

			# save ldap state for later comparison
			self.save_ldap_status()
			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv])
			# check for new users in LDAP
			self.check_new_and_removed_users(0, 0)
			# check school classes
			utils.verify_ldap_object(cls1_dn, expected_attr={'uniqueMember': [person.dn]}, strict=False, should_exist=True)
			utils.verify_ldap_object(cls2_dn, expected_attr={'uniqueMember': [person.dn]}, strict=False, should_exist=True)

		self.log.info('Test was successful.\n\n\n')

	def test_create_with_illegal_chars_in_username(self):
		"""
		Bug #42313: remove illegal characters from username
		* "Username must only contain numbers, letters and dots, and may not be 'admin'!"
		* but no dot at beginning
		"""
		allowed_chars = string.ascii_letters + string.digits + "."

		def remove_bad_chars(name):
			bad_chars = "".join(sorted(set(name).difference(set(allowed_chars))))
			name = name.strip(".")
			return name.translate(None, bad_chars)

		punkts = string.punctuation.translate(None, '[]')  # those will create bad counter vars

		for role in ('student', 'teacher', 'teacher_and_staff'):
			lastnames = ["{}{}{}".format(uts.random_username(5), x, uts.random_username(5)) for x in punkts]
			lastnames.append(".{}".format(uts.random_username()))
			lastnames.append(".{}.{}".format(uts.random_username(4), uts.random_username(4)))
			lastnames.append(uts.random_username(40))
			self.log.info('*** Importing new users with role %r and the following lastnames:\n%r', role, lastnames)

			config = copy.deepcopy(self.default_config)
			source_uid = 'sourceUID-%s' % (uts.random_string(),)
			config.update_entry('sourceUID', source_uid)
			config.update_entry('scheme:recordUID', '<record_uid>')
			config.update_entry('user_role', role)
			config.update_entry('csv:mapping:recordUID', 'record_uid')
			config.update_entry('scheme:username:default', "<lastname>[ALWAYSCOUNTER]")

			persons = list()
			names = dict()
			for lastname in lastnames:
				record_uid = uts.random_name()
				person = Person(self.ou_A.name, role)
				person.update(record_uid=record_uid, source_uid=source_uid, lastname=lastname)
				persons.append(person)
				names[person] = lastname
			fn_csv = self.create_csv_file(person_list=persons, mapping=config['csv']['mapping'])
			config.update_entry('input:filename', fn_csv)
			fn_config = self.create_config_json(config=config)

			# save ldap state for later comparison
			self.save_ldap_status()
			# start import
			self.run_import(['-c', fn_config, '-i', fn_csv])
			# check for new users in LDAP
			self.check_new_and_removed_users(len(persons), 0)
			# check usernames
			for person, lastname in names.items():
				person.update(username=remove_bad_chars("{}1".format(lastname[:12])))
				utils.verify_ldap_object(person.dn, expected_attr={'uid': [person.username]}, strict=False,
					should_exist=True)

		self.log.info('Test was successful.\n\n\n')

	def test_delete_variants(self):
		"""
		Bug #41344: support deletion of users in different ways

		* simply delete: user_deletion": {"delete": True, "expiration": 0}
		* do not delete, but deactivate with an expiration data: user_deletion": {"delete": False, "expiration": 7}
		  + creating a user with the deactived users SUID+RUID -> reactive account
		* store an expiration data (that is in the future) for the user, so it can
		  access its data for some days, before deletion: user_deletion": {"delete": True, "expiration": 7}
		"""
		self.log.info('*** 1/3: simply delete ***')
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			self.log.info('*** (1/3) Importing a new single user with role %r', role)
			person = Person(self.ou_A.name, role)
			source_uid = 'sourceUID-%s' % (uts.random_string(),)
			record_uid = 'recordUID-%s' % (uts.random_string(),)
			person.update(record_uid=record_uid, source_uid=source_uid)
			config = copy.deepcopy(self.default_config)
			config.update_entry('csv:mapping:Benutzername', 'username')
			config.update_entry('csv:mapping:recordUID', 'record_uid')
			config.update_entry('scheme:recordUID', '<record_uid>')
			config.update_entry('sourceUID', source_uid)
			config.update_entry('user_role', role)
			config.update_entry("user_deletion:delete", True)
			config.update_entry("user_deletion:expiration", 0)
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			config.update_entry('input:filename', fn_csv)
			fn_config = self.create_config_json(values=config)

			self.save_ldap_status()  # save ldap state for later comparison
			self.run_import(['-c', fn_config])  # start import
			self.check_new_and_removed_users(1, 0)  # check for new users in LDAP
			person.verify()  # verify LDAP attributes

			self.log.info('*** (1/3) Removing a single user with role %r', role)
			person.set_mode_to_delete()  # mark person as removed
			self.create_csv_file(person_list=[], fn_csv=fn_csv, mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(values=config)
			self.save_ldap_status()
			self.run_import(['-c', fn_config])
			self.check_new_and_removed_users(0, 1)
			person.verify()

		self.log.info('*** 2/3: do not delete, but deactivate with an expiration data ***')
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			exp_days = random.randint(1, 20)
			self.log.info('*** (2/3) Importing a new single user with role %r', role)
			person = Person(self.ou_A.name, role)
			source_uid = 'sourceUID-%s' % (uts.random_string(),)
			record_uid = 'recordUID-%s' % (uts.random_string(),)
			person.update(record_uid=record_uid, source_uid=source_uid)
			config = copy.deepcopy(self.default_config)
			config.update_entry('csv:mapping:Benutzername', 'username')
			config.update_entry('csv:mapping:recordUID', 'record_uid')
			config.update_entry('scheme:recordUID', '<record_uid>')
			config.update_entry('sourceUID', source_uid)
			config.update_entry('user_role', role)
			config.update_entry("user_deletion:delete", False)
			config.update_entry("user_deletion:expiration", exp_days)
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			config.update_entry('input:filename', fn_csv)
			fn_config = self.create_config_json(values=config)

			self.save_ldap_status()  # save ldap state for later comparison
			self.run_import(['-c', fn_config])  # start import
			self.check_new_and_removed_users(1, 0)  # check for new users in LDAP
			person.verify()  # verify LDAP attributes

			self.log.info('*** (2/3) Removing a single user with role %r', role)
			person.set_inactive()  # mark person as disabled
			self.create_csv_file(person_list=[], fn_csv=fn_csv, mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(values=config)
			self.save_ldap_status()
			self.run_import(['-c', fn_config])
			self.check_new_and_removed_users(0, 0)
			# check exp. date
			exp_date = (datetime.datetime.now() + datetime.timedelta(days=exp_days)).strftime("%Y-%m-%d")
			udm_value = self.udm_formula_for_shadowExpire(exp_date)
			self.log.debug('Account expiration date should be %r -> %r.', exp_date, udm_value)
			utils.verify_ldap_object(
				person.dn,
				expected_attr={
					'shadowExpire': [udm_value],
					'krb5KDCFlags': ['254'],
					'sambaAcctFlags': ['[UD         ]']},
				strict=False,
				should_exist=True)

			self.log.info('*** (2/3) Reactivating previously "deleted" user with role %r', role)
			person.set_active()
			self.create_csv_file(person_list=[person], fn_csv=fn_csv, mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(values=config)
			self.save_ldap_status()
			self.run_import(['-c', fn_config])
			self.check_new_and_removed_users(0, 0)
			person.verify()

		self.log.info('*** 3/3: store an expiration data for the user ***')
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			self.log.info('*** (3/3) Importing a new single user with role %r', role)
			exp_days = random.randint(1, 20)
			person = Person(self.ou_A.name, role)
			source_uid = 'sourceUID-%s' % (uts.random_string(),)
			record_uid = 'recordUID-%s' % (uts.random_string(),)
			person.update(record_uid=record_uid, source_uid=source_uid)
			config = copy.deepcopy(self.default_config)
			config.update_entry('csv:mapping:Benutzername', 'username')
			config.update_entry('csv:mapping:recordUID', 'record_uid')
			config.update_entry('scheme:recordUID', '<record_uid>')
			config.update_entry('sourceUID', source_uid)
			config.update_entry('user_role', role)
			config.update_entry("user_deletion:delete", True)
			config.update_entry("user_deletion:expiration", exp_days)
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			config.update_entry('input:filename', fn_csv)
			fn_config = self.create_config_json(values=config)

			self.save_ldap_status()  # save ldap state for later comparison
			self.run_import(['-c', fn_config])  # start import
			self.check_new_and_removed_users(1, 0)  # check for new users in LDAP
			person.verify()  # verify LDAP attributes

			self.log.info('*** (3/3) Removing a single user with role %r', role)
			self.create_csv_file(person_list=[], fn_csv=fn_csv, mapping=config['csv']['mapping'])
			fn_config = self.create_config_json(values=config)
			self.save_ldap_status()
			self.run_import(['-c', fn_config])
			self.check_new_and_removed_users(0, 0)
			# check exp. date
			exp_date = (datetime.datetime.now() + datetime.timedelta(days=exp_days)).strftime("%Y-%m-%d")
			utils.verify_ldap_object(
				person.dn,
				expected_attr={
					'shadowExpire': [self.udm_formula_for_shadowExpire(exp_date)],
					'krb5KDCFlags': ['126'],
					'sambaAcctFlags': ['[U          ]']},
				strict=False,
				should_exist=True)

		self.log.info('Test was successful.\n\n\n')

	def test_reuse_email_attribute(self):
		"""
		Bug #41544: test if it is possible to reuse an email address (-> if
		users are removed before they are added)
		"""
		for role in ('student', 'teacher', 'staff', 'teacher_and_staff'):
			source_uid = 'sourceUID-%s' % (uts.random_string(),)
			email = "{}@{}".format(uts.random_name(), self.ucr.get('domainname'))

			config = copy.deepcopy(self.default_config)
			config.update_entry('sourceUID', source_uid)
			config.update_entry('user_role', role)
			config.update_entry('scheme:email', '<email>')
			config.update_entry('scheme:recordUID', '<record_uid>')
			config.update_entry('csv:mapping:Benutzername', 'username')
			config.update_entry('csv:mapping:recordUID', 'record_uid')
			config.update_entry("user_deletion:delete", True)
			config.update_entry("user_deletion:expiration", 0)

			self.log.info('*** Importing a new single user with role %r and email address %r...', role, email)
			person = Person(self.ou_A.name, role)
			record_uid = uts.random_name()
			person.update(record_uid=record_uid, source_uid=source_uid, mail=email)
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			config.update_entry('input:filename', fn_csv)
			fn_config = self.create_config_json(config=config)
			self.save_ldap_status()
			self.run_import(['-c', fn_config])
			self.check_new_and_removed_users(1, 0)
			person.verify()

			self.log.info('*** Importing a new single user with role %r and same email address %r...', role, email)
			person = Person(self.ou_A.name, role)
			record_uid = uts.random_name()
			person.update(record_uid=record_uid, source_uid=source_uid, mail=email)
			fn_csv = self.create_csv_file(person_list=[person], mapping=config['csv']['mapping'])
			config.update_entry('input:filename', fn_csv)
			fn_config = self.create_config_json(config=config)
			self.save_ldap_status()
			self.run_import(['-c', fn_config])
			self.check_new_and_removed_users(1, 1)
			person.verify()
		self.log.info('*\n*** Test was successful.\n*')

	def run(self):
		try:
			with univention.testing.udm.UCSTestUDM() as udm:
				with utu.UCSTestSchool() as schoolenv:
					self.ou_A.name, self.ou_A.dn = schoolenv.create_ou(name_edudc=self.ucr.get('hostname'))
					self.ou_B.name, self.ou_B.dn = schoolenv.create_ou(name_edudc=self.ucr.get('hostname'))
					self.ou_C.name, self.ou_C.dn = schoolenv.create_ou(name_edudc=self.ucr.get('hostname'))
					self.lo = schoolenv.open_ldap_connection(admin=True)

					self.test_create_modify_delete_user()
					self.test_create_modify_delete_user_with_username_and_recordUID_and_UDM_property()
					self.test_create_with_username_scheme()
					self.test_create_modify_only()
					self.test_create_with_attribute_schemes()
					self.test_multivalue_attributes()
					self.test_school_change()
					self.test_iso_birthday()
					self.test_lowercase_username_with_counter()
					self.test_create_modify_with_extended_attribute(udm)
					self.test_create_with_empty_class_name()
					self.test_no_delete_option()
					self.test_modify_with_several_groups(udm)
					self.test_create_no_modify_classes_with_empty_class_name(udm)
					self.test_create_with_illegal_chars_in_username()
					self.test_delete_variants()
					self.test_reuse_email_attribute()
		finally:
			self.cleanup()


def main():
	logging.basicConfig(stream=sys.stdout, level=logging.DEBUG, format='%(levelname)s: %(funcName)s:%(lineno)d: %(message)s')
	tester = CLI_Import_v2_Tester()
	tester.run()


if __name__ == '__main__':
	main()
