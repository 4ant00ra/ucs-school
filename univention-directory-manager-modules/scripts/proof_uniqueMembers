#!/usr/bin/python2.6
# -*- coding: utf-8 -*-
#
# Univention Directory Manager Modules
#  check if users are member of their primary group
#
# Copyright 2004-2012 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.


import ldap, string
import sys
import univention.baseconfig
import pprint
from optparse import OptionParser

baseConfig=univention.baseconfig.baseConfig()
baseConfig.load()
binddn= "cn=admin," + baseConfig['ldap/base']
basedn = baseConfig['ldap/base']
count_changes = 0
warning = 0
pp = pprint.PrettyPrinter(indent=4)



parser = OptionParser()
parser.add_option("-b", "--base-dn", help="ldap base dn", dest="basedn", action="store", type="str")
(options, args) = parser.parse_args()

def ldapbind (binddn):
	bindpw=open('/etc/ldap.secret').read()
	bindpw = bindpw.split("\n")[0]
	lo=ldap.open('localhost', 7389)
	try:
		lo.simple_bind_s(binddn, bindpw)
	except:
		print "could not bind to %s" % binddn
		sys.exit(1)

	return lo


lo = ldapbind(binddn)


if options.basedn: basedn = options.basedn


# GID's will only be found in posixAccount
try:
	res_pA=lo.search_s(basedn, ldap.SCOPE_SUBTREE, 'objectClass=posixAccount', ['gidNumber'])
except ldap.NO_SUCH_OBJECT:
	print "ldap search in %s failed (no such base dn)" % basedn
	sys.exit(1)

print "\n  proof if users are member of their primary group"
for i in range(0,len(res_pA)):
	gidNumber_pA=''
	dn_pA=res_pA[i][0]
	if res_pA[i][1].has_key('gidNumber'):
		gidNumber_pA=res_pA[i][1]['gidNumber'][0]
	else:
		print "Warning, posixAccount without gidNumber",res_pA[i]
		warning = warning + 1

	# search corresponding group
	res_uG=lo.search_s(basedn, ldap.SCOPE_SUBTREE, '(&(objectClass=univentionGroup)(gidNumber='+gidNumber_pA+"))", ['uniqueMember'])

	# there must be excactly one group with this gid
	if len(res_uG)>1:
		print "Warning: found more than one univentionGroup for",dn_pA,"gidNumber",gidNumber_pA,"!"
		warning = warning + 1
	if len(res_uG)<1 and not gidNumber_pA=="0":
		print "Warning: found no univentionGroup for",dn_pA,"gidNumber",gidNumber_pA,"!"
		warning = warning +1
	# well change all if there are more -- the user needs to delete all but one of them
	for i in range(0,len(res_uG)):
		uniqueMember_uG = ()
		dn_uG=res_uG[i][0]
		found_uM = 0
		# look for the needed entry
		if res_uG[i][1].has_key('uniqueMember'):
			uniqueMember_uG = res_uG[i][1]['uniqueMember']
			for el in uniqueMember_uG:
				if el == dn_pA: found_uM = 1
		# no entry found, gonna add one
		if not found_uM:
			print "add uniqueMember entry for",dn_pA,"in",dn_uG
			modlist = [(ldap.MOD_ADD,'uniqueMember',dn_pA)]
			try:
				lo.modify_s(dn_uG,modlist)
				count_changes = count_changes +1
			except:
				print "Warning: failed to modify Group %s"%dn_uG
				warning = warning + 1

print "  proof of",len(res_pA),"posixAccounts finished, changed",count_changes,"of them.\n"

count_changes=0
print "  proof if group-members exist"
res_pG=lo.search_s(basedn, ldap.SCOPE_SUBTREE, 'objectClass=posixGroup', ['uniqueMember'])
for i in range(0,len(res_pG)):
	dn_pG = res_pG[i][0]
	members = []
	if res_pG[i][1].has_key('uniqueMember'):
		members = res_pG[i][1]['uniqueMember']

	remmembers=[]
	
	for member in members:
		n=string.find(member,',')
		base=member[n+1:]
		filter=member[:n]

		try:
			res_pU=lo.search_s(base, ldap.SCOPE_ONELEVEL, filter, ['objectClass'])
			if len(res_pU) > 1:
				print "Warning: more than one object found while searching for %s of group %s -- clear manually"%(member,dn_pG)
				warning+=1
			elif len(res_pU) < 1:
				print "  no object found while searching for %s, will be removed"%member
				remmembers.append(member)
		except:
			print "Warning: Search for member %s of group %s failed -- clear manually"%(member,dn_pG)
			warning+=1


	for member in remmembers:
		modlist = [(ldap.MOD_DELETE,'uniqueMember',member)]
		try:
			lo.modify_s(dn_pG,modlist)
			count_changes = count_changes +1
		except:
			print "Warning: failed to remove %s from Group %s"%(member,dn_pG)
			warning = warning + 1
			
print "  proof of",len(res_pG),"posixGroups finished, changed",count_changes,"of them.\n"


if warning: print "There were %s warning(s) !"%warning

